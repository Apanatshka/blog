<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Learn Rust by project | Whatever</title>
  <meta name="title" content="Learn Rust by project">
<meta name="description" content="A web log. Mostly about computer science-y stuff." />

  <meta name="referrer" content="no-referrer-when-downgrade">
  <link rel="alternate" type="application/rss+xml" title="Whatever" href="https://blog.jeffsmits.net/rss.xml">
  <link rel="stylesheet" href="https://blog.jeffsmits.net/style.css">
  </head>
<body>
  <header>
  

  <a href="https://blog.jeffsmits.net/" class="title">
    <h1>Whatever</h1>
  </a>
  <nav>
    

  

  </nav>
</header>

    <h1>Learn Rust by project</h1>
      <p>
        <i>
          <time datetime='2018-04-30T00:00:00+00:00' pubdate>30 Apr, 2018</time>
        </i>
      </p>
  <main>
    <p>More than a year ago a friend of mine wanted to learn a bit more about Rust by trying out a project. He had a nice project in mind which suits Rust quite well I think. For fun I joined his effort and created <a href="https://gitlab.com/Apanatshka/cobs">an implementation</a> at the same time as he did, discussing and comparing along the way. In this post I’ll tell you about the project specifics, but the point of the post is more an encouragement. If you’ve read about Rust before but haven’t tried it yet, find a small project like the one below, and learn Rust in a fun and hands-on way yourself. It’s a great programming language, I highly recommend it.</p>
<h1 id="the-project-consistent-overhead-byte-stuffing">The project: consistent overhead byte stuffing</h1>
<p>Computer networking can be messy business. Depending on what <a href="https://en.wikipedia.org/wiki/OSI_model#Description_of_OSI_layers">layer of the network</a> your software is operating in, you need to worry about different kinds of errors. If you’re receiving raw bytes, you might run into the issue of corrupted messages. You could throw away such a message entirely… Or you could try to chop it into chunks with a clear boundary and recover at the next boundary.</p>
<p>Byte stuffing is the process of stuffing bytes into a smaller range of values than the full byte, so you can use the unused values for something special like the boundaries of messages. The usual terminology is splitting your bytes of data into <em>frames</em> and using <em>sentinel values</em> to delimit the frames.</p>
<p>The problem that byte stuffing solves then, is what to do with values in your data that are the sentinel value you picked for delimiting frames. These should be turned into something else that can be reliably decoded again. The project of this post is to implement an algorithm for Consistent Overhead Byte Stuffing, or COBS. This algorithm has an overhead of at least one byte and at most one byte in 254 rounded up. If I’d been presented with this problem myself before I’d heard of COBS, I would have probably done something like pick two byte values, one delimiter and one “escape character”. The worst case for that is something like twice the size of the message. So this algorithm is pretty cool. I’ll explain it in my own words, but the <a href="https://en.wikipedia.org/wiki/Consistent_Overhead_Byte_Stuffing">Wikipedia article</a> is very nice too, so browse that if you don’t follow everything here.</p>
<h1 id="cobs-in-short">COBS in short</h1>
<p>Let’s choose zero as our sentinel values, our <em>frame marker</em>. If we need to recover from some error in the middle of the stream of frames, we just look for the next zero, that’s the end of a frame. Then the first byte is our consistent minimum overhead byte, which starts the COBS encoding. This byte tells us the offset to where the next zero should have been in the message. Until that offset is reached, the bytes should be the original message. If in those bytes you find a zero, the message is definitely corrupted and you should skip to the next frame. Once you reach the offset, instead of a zero you should find another number, which is the offset from there to the next zero in the original message. So each zero is turned into a higher number of where the next zero is. The last zero points to the place where the zero of the end of the frame should be<sup class="footnote-reference" id="fr-overhead-1"><a href="#fn-overhead">[1]</a></sup>.</p>
<p>Let’s call these offsets to a zero <em>zero markers</em>. The first <em>zero marker</em> is <em>fake</em>, since it doesn’t mark a zero at its place. We need it to point out the first actual zero. There can be more fake zero markers in the message, and this is where the worst case overhead comes from: what if two zeroes are further apart than the size of a byte? Assuming we’re speaking of <a href="https://en.wikipedia.org/wiki/Octet_(computing)">octets</a>, which is usually the case these days, we have 0-255 as the normal value range. We’re changing that range to 1-255. So if 255 is the maximum value for our zero marker, we cannot have more than 254 consecutive non-zero bytes. To fix this we say that zero markers with value 255 signify that the <em>next</em> zero marker is <em>fake</em>. Again, a fake zero marker does not signify a zero, but just how many bytes to read until we reach the next zero marker.</p>
<h1 id="cobs-in-rust">COBS in Rust</h1>
<p>Now that we’ve seen a prose description of COBS in Rust, let’s implement an encode and a decode function for COBS. In this case I’ll present an implementation that is uses a sentinel value of zero, adds that zero as part of the encode procedure, and expects it during decode. Note that this is not going to be the most beautiful implementation possible. We’re not using traits from Rust’s standard library, such as <code>Read</code> and <code>Write</code> even though these work with bytes. We’re hard-coding the sentinel value to <code>0</code>.</p>
<h2 id="tests">Tests</h2>
<p>To start things off, let’s define the types for encode and decode, and then write some tests to make our understanding of the algorithm executable. We start out with some unit tests, and some property based tests using <a href="https://crates.io/crates/quickcheck">quickcheck</a>. Property based tests use a function from some input to boolean and given that input check if a property holds.</p>
<p>With the property based tests we check that encoding and decoding a given vector of bytes comes to the same thing. The quickcheck framework then generates some random vectors of bytes and checks if our property holds. If it doesn’t, the framework shrinks the counter example with some heuristics. It’s pretty cool stuff. I recommend using this form of testing whenever you can.</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#5c6773;">//! Consistent overhead byte stuffing
</span><span style="font-style:italic;color:#5c6773;">//! =================================
</span><span style="font-style:italic;color:#5c6773;">//!
</span><span style="font-style:italic;color:#5c6773;">//! This encoding allows for packet loss in a stream of bytes by dividing data into frames.
</span><span style="font-style:italic;color:#5c6773;">//!
</span><span style="font-style:italic;color:#5c6773;">//! 0 = framemarker, the thing you search for when you recover in the middle of a stream. It marks
</span><span style="font-style:italic;color:#5c6773;">//!  the end of a frame.
</span><span style="font-style:italic;color:#5c6773;">//! Zeromarkers both mark a zero and have a value of where the next zeromarker is. There are also
</span><span style="font-style:italic;color:#5c6773;">//! special zeromarkers, which say the next zeromarker is fake. Fake zeromarkers don&#39;t mark zeroes,
</span><span style="font-style:italic;color:#5c6773;">//! they only tell where the next zeromarker is.
</span><span style="font-style:italic;color:#5c6773;">//! The first byte of a frame is a fake zeromarker.
</span><span style="font-style:italic;color:#5c6773;">//! Other bytes are normal bytes.
</span><span style="font-style:italic;color:#5c6773;">//! When normally (in the original data) the next zero occurs, this is another zeromarker. The
</span><span style="font-style:italic;color:#5c6773;">//!  first (fake) zeromarker will have the offset after which the next zeromarker occurs.
</span><span style="font-style:italic;color:#5c6773;">//! The special zeromarker 255 predicts that the next zeromarker is fake. The reason for calling it
</span><span style="font-style:italic;color:#5c6773;">//! fake is to support data where the are more than 255 bytes between zeroes.
</span><span>
</span><span style="color:#bfbab0cc;">#</span><span>[</span><span style="color:#ffb454;">cfg</span><span>(test)]
</span><span style="color:#bfbab0cc;">#</span><span>[</span><span style="color:#ffb454;">macro_use</span><span>]
</span><span style="color:#ff7733;">extern crate</span><span> quickcheck</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span style="color:#ff7733;">use </span><span>std</span><span style="color:#f29668;">::</span><span>iter</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span style="color:#ff7733;">pub fn </span><span style="color:#ffb454;">encode</span><span>(</span><span style="color:#f29718;">data</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span>[</span><span style="color:#ff7733;">u8</span><span>], </span><span style="color:#f29718;">encoded_data_buffer</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="color:#ff7733;">u8</span><span>&gt;) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="color:#ff7733;">usize </span><span>{
</span><span>    </span><span style="color:#f07178;">unimplemented!</span><span>()
</span><span>}
</span><span>
</span><span style="color:#ff7733;">pub fn </span><span style="color:#ffb454;">decode</span><span>(</span><span style="color:#f29718;">encoded_data</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span>[</span><span style="color:#ff7733;">u8</span><span>], </span><span style="color:#f29718;">decoded_data_buffer</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="color:#ff7733;">u8</span><span>&gt;) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="font-style:italic;color:#39bae6;">Result</span><span>&lt;</span><span style="color:#ff7733;">usize</span><span>, </span><span style="color:#ff7733;">usize</span><span>&gt; {
</span><span>    </span><span style="color:#f07178;">unimplemented!</span><span>()
</span><span>}
</span><span>
</span><span style="color:#ff7733;">pub fn </span><span style="color:#ffb454;">max_encoded_size</span><span>(</span><span style="color:#f29718;">input_size</span><span style="color:#bfbab0cc;">: </span><span style="color:#ff7733;">usize</span><span>) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="color:#ff7733;">usize </span><span>{
</span><span>    input_size </span><span style="color:#f29668;">* </span><span>(</span><span style="color:#ff7733;">u8</span><span style="color:#f29668;">::</span><span>max_value() </span><span style="color:#f29668;">as </span><span style="color:#ff7733;">f32 </span><span style="color:#f29668;">/ </span><span>(</span><span style="color:#ff7733;">u8</span><span style="color:#f29668;">::</span><span>max_value() </span><span style="color:#f29668;">- </span><span style="color:#f29718;">1</span><span>) </span><span style="color:#f29668;">as </span><span style="color:#ff7733;">f32</span><span>)</span><span style="color:#f29668;">.</span><span style="color:#f07178;">ceil</span><span>() </span><span style="color:#f29668;">as </span><span style="color:#ff7733;">usize </span><span style="color:#f29668;">+ </span><span style="color:#f29718;">1
</span><span>}
</span><span>
</span><span style="color:#ff7733;">pub fn </span><span style="color:#ffb454;">max_decoded_size</span><span>(</span><span style="color:#f29718;">encoded_size</span><span style="color:#bfbab0cc;">: </span><span style="color:#ff7733;">usize</span><span>) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="color:#ff7733;">usize </span><span>{
</span><span>    encoded_size </span><span style="color:#f29668;">- </span><span style="color:#f29718;">2
</span><span>}
</span><span>
</span><span style="color:#bfbab0cc;">#</span><span>[</span><span style="color:#ffb454;">cfg</span><span>(test)]
</span><span style="color:#ff7733;">mod </span><span style="color:#59c2ff;">tests </span><span>{
</span><span>    </span><span style="color:#f07178;">macro_rules! </span><span style="color:#59c2ff;">unit_test_set </span><span>{
</span><span>        (</span><span style="color:#f29718;">$assert</span><span style="color:#bfbab0cc;">:</span><span style="color:#ff7733;">path</span><span>) </span><span style="color:#f29668;">=&gt; </span><span>{
</span><span>            </span><span style="color:#bfbab0cc;">#</span><span>[</span><span style="color:#ffb454;">test</span><span>]
</span><span>            </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">empty</span><span>() {
</span><span>                $assert(</span><span style="color:#f29668;">&amp;</span><span>[]</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29668;">&amp;</span><span>[</span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">0</span><span>])</span><span style="color:#bfbab0cc;">;
</span><span>            }
</span><span>
</span><span>            </span><span style="color:#bfbab0cc;">#</span><span>[</span><span style="color:#ffb454;">test</span><span>]
</span><span>            </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">zero</span><span>() {
</span><span>                $assert(</span><span style="color:#f29668;">&amp;</span><span>[</span><span style="color:#f29718;">0</span><span>]</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29668;">&amp;</span><span>[</span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">0</span><span>])</span><span style="color:#bfbab0cc;">;
</span><span>            }
</span><span>
</span><span>            </span><span style="color:#bfbab0cc;">#</span><span>[</span><span style="color:#ffb454;">test</span><span>]
</span><span>            </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">one</span><span>() {
</span><span>                $assert(</span><span style="color:#f29668;">&amp;</span><span>[</span><span style="color:#f29718;">1</span><span>]</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29668;">&amp;</span><span>[</span><span style="color:#f29718;">2</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">0</span><span>])</span><span style="color:#bfbab0cc;">;
</span><span>            }
</span><span>
</span><span>            </span><span style="color:#bfbab0cc;">#</span><span>[</span><span style="color:#ffb454;">test</span><span>]
</span><span>            </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">byte_max</span><span>() {
</span><span>                $assert(</span><span style="color:#f29668;">&amp;</span><span>[</span><span style="color:#f29718;">255</span><span>]</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29668;">&amp;</span><span>[</span><span style="color:#f29718;">2</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">255</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">0</span><span>])</span><span style="color:#bfbab0cc;">;
</span><span>            }
</span><span>
</span><span>            </span><span style="color:#bfbab0cc;">#</span><span>[</span><span style="color:#ffb454;">test</span><span>]
</span><span>            </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">five_zeroes</span><span>() {
</span><span>                $assert(</span><span style="color:#f29668;">&amp;</span><span>[</span><span style="color:#f29718;">0</span><span style="color:#bfbab0cc;">; </span><span style="color:#f29718;">5</span><span>]</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29668;">&amp;</span><span>[</span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">0</span><span>])</span><span style="color:#bfbab0cc;">;
</span><span>            }
</span><span>
</span><span>            </span><span style="color:#bfbab0cc;">#</span><span>[</span><span style="color:#ffb454;">test</span><span>]
</span><span>            </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">five_ones</span><span>() {
</span><span>                $assert(</span><span style="color:#f29668;">&amp;</span><span>[</span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">; </span><span style="color:#f29718;">5</span><span>]</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29668;">&amp;</span><span>[</span><span style="color:#f29718;">6</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">0</span><span>])</span><span style="color:#bfbab0cc;">;
</span><span>            }
</span><span>
</span><span>            </span><span style="color:#bfbab0cc;">#</span><span>[</span><span style="color:#ffb454;">test</span><span>]
</span><span>            </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">byte_max_zeroes</span><span>() {
</span><span>                </span><span style="color:#ff7733;">let mut</span><span> output </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">Vec</span><span style="color:#f29668;">::</span><span>with_capacity(</span><span style="color:#f29718;">257</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>                output</span><span style="color:#f29668;">.</span><span style="color:#f07178;">extend_from_slice</span><span>(</span><span style="color:#f29668;">&amp;</span><span>[</span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">; </span><span style="color:#f29718;">256</span><span>])</span><span style="color:#bfbab0cc;">;
</span><span>                output</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(</span><span style="color:#f29718;">0</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>                $assert(</span><span style="color:#f29668;">&amp;</span><span>[</span><span style="color:#f29718;">0</span><span style="color:#bfbab0cc;">; </span><span style="color:#f29718;">255</span><span>]</span><span style="color:#bfbab0cc;">,</span><span> output</span><span style="color:#f29668;">.</span><span style="color:#f07178;">as_slice</span><span>())</span><span style="color:#bfbab0cc;">;
</span><span>            }
</span><span>
</span><span>            </span><span style="color:#bfbab0cc;">#</span><span>[</span><span style="color:#ffb454;">test</span><span>]
</span><span>            </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">byte_max_ones</span><span>() {
</span><span>                </span><span style="color:#ff7733;">let mut</span><span> output </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">Vec</span><span style="color:#f29668;">::</span><span>with_capacity(</span><span style="color:#f29718;">258</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>                output</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(</span><span style="color:#f29718;">255</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>                output</span><span style="color:#f29668;">.</span><span style="color:#f07178;">extend_from_slice</span><span>(</span><span style="color:#f29668;">&amp;</span><span>[</span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">;</span><span style="color:#f29718;">254</span><span>])</span><span style="color:#bfbab0cc;">;
</span><span>                output</span><span style="color:#f29668;">.</span><span style="color:#f07178;">extend_from_slice</span><span>(</span><span style="color:#f29668;">&amp;</span><span>[</span><span style="color:#f29718;">2</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">0</span><span>])</span><span style="color:#bfbab0cc;">;
</span><span>                $assert(</span><span style="color:#f29668;">&amp;</span><span>[</span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">; </span><span style="color:#f29718;">255</span><span>]</span><span style="color:#bfbab0cc;">,</span><span> output</span><span style="color:#f29668;">.</span><span style="color:#f07178;">as_slice</span><span>())</span><span style="color:#bfbab0cc;">;
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#ff7733;">mod </span><span style="color:#59c2ff;">encode </span><span>{
</span><span>        </span><span style="color:#ff7733;">use super</span><span style="color:#f29668;">::</span><span style="color:#ff7733;">super</span><span style="color:#f29668;">::</span><span>encode</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>        </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">check_encoded_vs_given</span><span>(</span><span style="color:#f29718;">data</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span>[</span><span style="color:#ff7733;">u8</span><span>], </span><span style="color:#f29718;">encoded</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span>[</span><span style="color:#ff7733;">u8</span><span>]) {
</span><span>            </span><span style="color:#ff7733;">let mut</span><span> buffer </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">Vec</span><span style="color:#f29668;">::</span><span>new()</span><span style="color:#bfbab0cc;">;
</span><span>            </span><span style="color:#ff7733;">let </span><span style="color:#f29668;">_ = </span><span style="color:#f07178;">encode</span><span>(data</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut</span><span> buffer)</span><span style="color:#bfbab0cc;">;
</span><span>            </span><span style="color:#f07178;">assert_eq!</span><span>(encoded</span><span style="color:#bfbab0cc;">,</span><span> buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">as_slice</span><span>())</span><span style="color:#bfbab0cc;">;
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#f07178;">unit_test_set!</span><span>(check_encoded_vs_given)</span><span style="color:#bfbab0cc;">;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#ff7733;">mod </span><span style="color:#59c2ff;">decode </span><span>{
</span><span>        </span><span style="color:#ff7733;">use super</span><span style="color:#f29668;">::</span><span style="color:#ff7733;">super</span><span style="color:#f29668;">::</span><span>decode</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>        </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">check_decoded_vs_given</span><span>(</span><span style="color:#f29718;">data</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span>[</span><span style="color:#ff7733;">u8</span><span>], </span><span style="color:#f29718;">encoded</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span>[</span><span style="color:#ff7733;">u8</span><span>]) {
</span><span>            </span><span style="color:#ff7733;">let mut</span><span> buffer </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">Vec</span><span style="color:#f29668;">::</span><span>new()</span><span style="color:#bfbab0cc;">;
</span><span>            </span><span style="color:#ff7733;">let </span><span style="color:#f29668;">_ = </span><span style="color:#f07178;">decode</span><span>(encoded</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut</span><span> buffer)</span><span style="color:#bfbab0cc;">;
</span><span>            </span><span style="color:#f07178;">assert_eq!</span><span>(data</span><span style="color:#bfbab0cc;">,</span><span> buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">as_slice</span><span>())</span><span style="color:#bfbab0cc;">;
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#f07178;">unit_test_set!</span><span>(check_decoded_vs_given)</span><span style="color:#bfbab0cc;">;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#ff7733;">use super</span><span style="color:#f29668;">::</span><span>{encode</span><span style="color:#bfbab0cc;">,</span><span> decode}</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>    </span><span style="color:#f07178;">quickcheck! </span><span>{
</span><span>        </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">encode_decode_identity</span><span>(</span><span style="color:#f29718;">data</span><span style="color:#bfbab0cc;">: </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="color:#ff7733;">u8</span><span>&gt;) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="color:#ff7733;">bool </span><span>{
</span><span>            </span><span style="color:#ff7733;">let mut</span><span> b1 </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">Vec</span><span style="color:#f29668;">::</span><span>new()</span><span style="color:#bfbab0cc;">;
</span><span>            </span><span style="color:#ff7733;">let mut</span><span> b2 </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">Vec</span><span style="color:#f29668;">::</span><span>new()</span><span style="color:#bfbab0cc;">;
</span><span>            </span><span style="color:#ff7733;">let </span><span style="color:#f29668;">_ = </span><span style="color:#f07178;">encode</span><span>(data</span><span style="color:#f29668;">.</span><span style="color:#f07178;">as_slice</span><span>()</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut</span><span> b1)</span><span style="color:#bfbab0cc;">;
</span><span>            </span><span style="color:#ff7733;">let </span><span style="color:#f29668;">_ = </span><span style="color:#f07178;">decode</span><span>(b1</span><span style="color:#f29668;">.</span><span style="color:#f07178;">as_slice</span><span>()</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut</span><span> b2)</span><span style="color:#bfbab0cc;">;
</span><span>            data </span><span style="color:#f29668;">==</span><span> b2
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<h2 id="constants">Constants</h2>
<p>I really dislike magic values in my code. Here are some constants we’ll use:</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">const</span><span> MAXu8</span><span style="color:#bfbab0cc;">: </span><span style="color:#ff7733;">u8 </span><span style="color:#f29668;">= </span><span style="color:#ff7733;">u8</span><span style="color:#f29668;">::</span><span>max_value()</span><span style="color:#bfbab0cc;">;
</span><span style="color:#ff7733;">const </span><span style="color:#f29718;">MAX</span><span style="color:#bfbab0cc;">: </span><span style="color:#ff7733;">usize </span><span style="color:#f29668;">=</span><span> MAXu8 </span><span style="color:#f29668;">as </span><span style="color:#ff7733;">usize</span><span style="color:#bfbab0cc;">;
</span><span style="color:#ff7733;">const </span><span style="color:#f29718;">MAX_CONSECUTIVE</span><span style="color:#bfbab0cc;">: </span><span style="color:#ff7733;">usize </span><span style="color:#f29668;">= </span><span style="color:#f29718;">MAX </span><span style="color:#f29668;">- </span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">;
</span></code></pre>
<p>The <code>MAX*</code> values are just shorter without using <code>255</code> literally. I did use them in the tests because there are related numbers off by 2 or 3. It made more sense in the unit tests, which encode specific examples. The code is abstract, should work for any case.</p>
<h2 id="decode">Decode</h2>
<p>So let’s decode some bytes. For every byte we can either interpret it as a zero marker if it’s at the right offset, or we can copy the byte to the output verbatim. If the copied byte is zero, that’s an error. Unless it’s a predicted zero marker, in which case we’re successfully finished. If it’s a zero marker that’s not fake, we push a zero instead of the byte value of the marker. We also need to compute the index of the next zero marker with the relative offset. This boils down to the following code:</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">pub fn </span><span style="color:#ffb454;">decode</span><span>(</span><span style="color:#f29718;">encoded_data</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span>[</span><span style="color:#ff7733;">u8</span><span>],
</span><span>              </span><span style="color:#f29718;">decoded_data_buffer</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="color:#ff7733;">u8</span><span>&gt;)
</span><span>              </span><span style="color:#bfbab0cc;">-&gt; </span><span style="font-style:italic;color:#39bae6;">Result</span><span>&lt;</span><span style="color:#ff7733;">usize</span><span>, </span><span style="color:#ff7733;">usize</span><span>&gt; {
</span><span>    </span><span style="color:#ff7733;">let mut</span><span> zero_marker_index</span><span style="color:#bfbab0cc;">: </span><span style="color:#ff7733;">usize </span><span style="color:#f29668;">= </span><span style="color:#f29718;">0</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#ff7733;">let mut</span><span> fake </span><span style="color:#f29668;">= </span><span style="color:#f29718;">true</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#ff7733;">let mut</span><span> written </span><span style="color:#f29668;">= </span><span style="color:#f29718;">0</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#ff7733;">for </span><span>(index</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29668;">&amp;</span><span>byte) </span><span style="color:#f29668;">in</span><span> encoded_data</span><span style="color:#f29668;">.</span><span style="color:#f07178;">iter</span><span>()</span><span style="color:#f29668;">.</span><span style="color:#f07178;">enumerate</span><span>() {
</span><span>        </span><span style="color:#ff7733;">if</span><span> index </span><span style="color:#f29668;">==</span><span> zero_marker_index {
</span><span>            </span><span style="color:#ff7733;">if</span><span> byte </span><span style="color:#f29668;">== </span><span style="color:#f29718;">0 </span><span>{
</span><span>                </span><span style="color:#ff7733;">return </span><span style="font-style:italic;color:#39bae6;">Ok</span><span>(written)</span><span style="color:#bfbab0cc;">; </span><span style="font-style:italic;color:#5c6773;">// framemarker, we&#39;re done
</span><span>            }
</span><span>            </span><span style="color:#ff7733;">if </span><span style="color:#f29668;">!</span><span>fake {
</span><span>                decoded_data_buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(</span><span style="color:#f29718;">0</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>                written </span><span style="color:#f29668;">+= </span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">;
</span><span>            }
</span><span>            zero_marker_index </span><span style="color:#f29668;">=</span><span> index </span><span style="color:#f29668;">+</span><span> byte </span><span style="color:#f29668;">as </span><span style="color:#ff7733;">usize</span><span style="color:#bfbab0cc;">;
</span><span>            fake </span><span style="color:#f29668;">=</span><span> byte </span><span style="color:#f29668;">==</span><span> MAXu8</span><span style="color:#bfbab0cc;">;
</span><span>        } </span><span style="color:#ff7733;">else </span><span>{
</span><span>            </span><span style="color:#ff7733;">if</span><span> byte </span><span style="color:#f29668;">== </span><span style="color:#f29718;">0 </span><span>{
</span><span>                </span><span style="color:#ff7733;">break</span><span style="color:#bfbab0cc;">; </span><span style="font-style:italic;color:#5c6773;">// fail
</span><span>            }
</span><span>            decoded_data_buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(byte)</span><span style="color:#bfbab0cc;">;
</span><span>            written </span><span style="color:#f29668;">+= </span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">;
</span><span>        }
</span><span>    }
</span><span>    </span><span style="font-style:italic;color:#39bae6;">Err</span><span>(written) </span><span style="font-style:italic;color:#5c6773;">// fail
</span><span>}
</span></code></pre>
<p>The <code>zero_marker_index</code> is the absolute offset from the start of the <code>encoded_data</code> slice. The boolean <code>fake</code> is for remembering if that zero marker will be fake or not. We also track how many bytes we’ve <code>written</code> in the buffer of decoded data. We break from the loop to fail, because we may also find no <code>0</code> at all and run out of encoded data, which is also a corner case where we should fail.</p>
<h2 id="encode-buffer-input">Encode (buffer input)</h2>
<p>There are two different ways you can implement COBS. One is to look ahead in the data for the zero. This means to need a buffer of 254 bytes at most, but you can sequentially output the encoded bytes. Is to sequentially read the input byte without buffering them, instead buffering the output so you can go back and fill in the space you reserved for the zero marker once you’ve seen the next zero. Let’s first look at the look-ahead version:</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">pub fn </span><span style="color:#ffb454;">encode_lookahead</span><span>(</span><span style="color:#f29718;">data</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span>[</span><span style="color:#ff7733;">u8</span><span>], </span><span style="color:#f29718;">encoded_data_buffer</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="color:#ff7733;">u8</span><span>&gt;) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="color:#ff7733;">usize </span><span>{
</span><span>    </span><span style="color:#ff7733;">let</span><span> start_length_out_buffer </span><span style="color:#f29668;">=</span><span> encoded_data_buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">len</span><span>()</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>    </span><span style="color:#ff7733;">let mut</span><span> data_iter </span><span style="color:#f29668;">=</span><span> data</span><span style="color:#f29668;">.</span><span style="color:#f07178;">iter</span><span>()</span><span style="color:#f29668;">.</span><span style="color:#f07178;">chain</span><span>(iter</span><span style="color:#f29668;">::</span><span>once(</span><span style="color:#f29668;">&amp;</span><span style="color:#f29718;">0</span><span>))</span><span style="color:#f29668;">.</span><span style="color:#f07178;">peekable</span><span>()</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#ff7733;">let mut</span><span> buf </span><span style="color:#f29668;">= </span><span>[</span><span style="color:#f29718;">0_</span><span style="color:#ff7733;">u8</span><span style="color:#bfbab0cc;">; </span><span style="color:#f29718;">MAX_CONSECUTIVE</span><span>]</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#ff7733;">let mut</span><span> buf_index</span><span style="color:#bfbab0cc;">: </span><span style="color:#ff7733;">usize</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>    </span><span style="color:#ff7733;">while let </span><span style="font-style:italic;color:#39bae6;">Some</span><span>(</span><span style="color:#f29668;">_</span><span>) </span><span style="color:#f29668;">=</span><span> data_iter</span><span style="color:#f29668;">.</span><span style="color:#f07178;">peek</span><span>() {
</span><span>        buf_index </span><span style="color:#f29668;">= </span><span style="color:#f29718;">0</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>        </span><span style="font-style:italic;color:#5c6773;">// Find the next zero, copy bytes seen into buffer
</span><span>        </span><span style="color:#ff7733;">for </span><span style="color:#f29668;">&amp;</span><span>byte </span><span style="color:#f29668;">in</span><span> data_iter</span><span style="color:#f29668;">.</span><span style="color:#f07178;">by_ref</span><span>()</span><span style="color:#f29668;">.</span><span style="color:#f07178;">take_while</span><span>(|</span><span style="color:#f29668;">&amp;&amp;</span><span style="color:#f29718;">b</span><span>| b </span><span style="color:#f29668;">!= </span><span style="color:#f29718;">0</span><span>) {
</span><span>            buf[buf_index] </span><span style="color:#f29668;">=</span><span> byte</span><span style="color:#bfbab0cc;">;
</span><span>            buf_index </span><span style="color:#f29668;">+= </span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">;
</span><span>            </span><span style="color:#f07178;">debug_assert!</span><span>(buf_index </span><span style="color:#f29668;">&lt;=</span><span> buf</span><span style="color:#f29668;">.</span><span style="color:#f07178;">len</span><span>())</span><span style="color:#bfbab0cc;">;
</span><span>            </span><span style="color:#ff7733;">if</span><span> buf_index </span><span style="color:#f29668;">==</span><span> buf</span><span style="color:#f29668;">.</span><span style="color:#f07178;">len</span><span>() {
</span><span>                </span><span style="color:#ff7733;">break</span><span style="color:#bfbab0cc;">;
</span><span>            }
</span><span>        }
</span><span>
</span><span>        </span><span style="font-style:italic;color:#5c6773;">// Write where next zero is, then write the data from the buffer
</span><span>        </span><span style="font-style:italic;color:#5c6773;">// Note the +1, since buf_index starts at zero and the next zero is always at least one away
</span><span>        encoded_data_buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(buf_index </span><span style="color:#f29668;">as </span><span style="color:#ff7733;">u8 </span><span style="color:#f29668;">+ </span><span style="color:#f29718;">1</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>        encoded_data_buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">extend_from_slice</span><span>(</span><span style="color:#f29668;">&amp;</span><span>buf[</span><span style="color:#f29718;">0</span><span style="color:#f29668;">..</span><span>buf_index])</span><span style="color:#bfbab0cc;">;
</span><span>    }
</span><span>
</span><span>    encoded_data_buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(</span><span style="color:#f29718;">0</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>    encoded_data_buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">len</span><span>() </span><span style="color:#f29668;">-</span><span> start_length_out_buffer
</span><span>}
</span></code></pre>
<p>Given that we take in some <code>Vec&lt;u8&gt;</code> that we append to, we should save the length and return the difference in length as the amount of bytes written. Then we create an iterator over the data, followed by an extra zero, which should be <code>peekable</code>. This means we can look ahead without consuming to see if the iterator is done yet. While it isn’t done, we set keep an index of the used part of the buffer. For the bytes in the iterator, we just add them to the buffer unless it’s a zero or the buffer is full. Then we write the zero marker first using the buffer index to see how many non-zeroes we found ahead. And we copy over the buffer. The extra zero on the data iterator compensates for the extra zero-marker at the front of the message. The extra zero pushed at the end ends the message.</p>
<h2 id="encode-buffer-output">Encode (buffer output)</h2>
<p>If we buffer the output, we can just write a bogus value for the zero marker, remember its index, and overwrite it later. Again only 255 bytes need to be buffered at a maximum, although this isn’t visible in our implementation.</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">pub fn </span><span style="color:#ffb454;">encode</span><span>(</span><span style="color:#f29718;">data</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span>[</span><span style="color:#ff7733;">u8</span><span>], </span><span style="color:#f29718;">encoded_data_buffer</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="color:#ff7733;">u8</span><span>&gt;) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="color:#ff7733;">usize </span><span>{
</span><span>    </span><span style="color:#ff7733;">let</span><span> start_length_out_buffer </span><span style="color:#f29668;">=</span><span> encoded_data_buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">len</span><span>()</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Note that we always start from 1, so we count MAX_CONSEQUTIVE bytes of non-zero data
</span><span>    </span><span style="color:#ff7733;">let mut</span><span> non_zero_count </span><span style="color:#f29668;">= </span><span style="color:#f29718;">1_</span><span style="color:#ff7733;">usize</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#ff7733;">let mut</span><span> zero_marker_index</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>    </span><span style="color:#f07178;">macro_rules! </span><span style="color:#59c2ff;">next_zero_marker </span><span>{ () </span><span style="color:#f29668;">=&gt; </span><span>{
</span><span>        encoded_data_buffer[zero_marker_index] </span><span style="color:#f29668;">=</span><span> non_zero_count </span><span style="color:#f29668;">as </span><span style="color:#ff7733;">u8</span><span style="color:#bfbab0cc;">;
</span><span>        non_zero_count </span><span style="color:#f29668;">= </span><span style="color:#f29718;">1_</span><span style="color:#ff7733;">usize</span><span style="color:#bfbab0cc;">;
</span><span>        zero_marker_index </span><span style="color:#f29668;">=</span><span> encoded_data_buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">len</span><span>()</span><span style="color:#bfbab0cc;">;
</span><span>        encoded_data_buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(</span><span style="color:#f29718;">0</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>    }}</span><span style="color:#bfbab0cc;">;
</span><span>    zero_marker_index </span><span style="color:#f29668;">=</span><span> encoded_data_buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">len</span><span>()</span><span style="color:#bfbab0cc;">;
</span><span>    encoded_data_buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(</span><span style="color:#f29718;">0</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// NOTE: the extra zero at the end will become the framemarker
</span><span>    </span><span style="color:#ff7733;">for </span><span style="color:#f29668;">&amp;</span><span>byte </span><span style="color:#f29668;">in</span><span> data</span><span style="color:#f29668;">.</span><span style="color:#f07178;">iter</span><span>()</span><span style="color:#f29668;">.</span><span style="color:#f07178;">chain</span><span>(iter</span><span style="color:#f29668;">::</span><span>once(</span><span style="color:#f29668;">&amp;</span><span style="color:#f29718;">0</span><span>)) {
</span><span>        </span><span style="color:#ff7733;">if</span><span> byte </span><span style="color:#f29668;">== </span><span style="color:#f29718;">0 </span><span>{
</span><span>            </span><span style="color:#f07178;">next_zero_marker!</span><span>()</span><span style="color:#bfbab0cc;">;
</span><span>        } </span><span style="color:#ff7733;">else </span><span>{
</span><span>            encoded_data_buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(byte)</span><span style="color:#bfbab0cc;">;
</span><span>            non_zero_count </span><span style="color:#f29668;">+= </span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">;
</span><span>            </span><span style="color:#f07178;">debug_assert!</span><span>(non_zero_count </span><span style="color:#f29668;">&lt;= </span><span style="color:#f29718;">MAX</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>            </span><span style="color:#ff7733;">if</span><span> non_zero_count </span><span style="color:#f29668;">== </span><span style="color:#f29718;">MAX </span><span>{
</span><span>                </span><span style="color:#f07178;">next_zero_marker!</span><span>()</span><span style="color:#bfbab0cc;">;
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    encoded_data_buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">len</span><span>() </span><span style="color:#f29668;">-</span><span> start_length_out_buffer
</span><span>}
</span></code></pre>
<p>In the end, I don’t think the memory requirements and timing behaviour of the two different options should be very different. But to put that to the test, I’ve written a little benchmark:</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#f07178;">macro_rules! </span><span style="color:#59c2ff;">gen_benches </span><span>{
</span><span>    (</span><span style="color:#f29718;">$prefix</span><span style="color:#bfbab0cc;">:</span><span style="color:#ff7733;">ident</span><span>) </span><span style="color:#f29668;">=&gt; </span><span>{
</span><span>        </span><span style="color:#ff7733;">mod </span><span>$prefix {
</span><span>            </span><span style="color:#ff7733;">use </span><span>test</span><span style="color:#f29668;">::</span><span>Bencher</span><span style="color:#bfbab0cc;">;
</span><span>            </span><span style="color:#ff7733;">use </span><span>cobs</span><span style="color:#f29668;">::</span><span>$prefix</span><span style="color:#bfbab0cc;">;
</span><span>            </span><span style="color:#ff7733;">use super</span><span style="color:#f29668;">::</span><span style="color:#f29718;">LOREM_IPSUM_RAW</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>            </span><span style="color:#bfbab0cc;">#</span><span>[</span><span style="color:#ffb454;">bench</span><span>]
</span><span>            </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">encode_r1</span><span>(</span><span style="color:#f29718;">b</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut</span><span> Bencher) {
</span><span>                b</span><span style="color:#f29668;">.</span><span style="color:#f07178;">iter</span><span>(|| {
</span><span>                    </span><span style="color:#ff7733;">let mut</span><span> lorem_ipsum_encoded </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">Vec</span><span style="color:#f29668;">::</span><span>new()</span><span style="color:#bfbab0cc;">;
</span><span>                    </span><span style="color:#ff7733;">let </span><span style="color:#f29668;">_ = </span><span>$prefix(</span><span style="color:#f29718;">LOREM_IPSUM_RAW</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut</span><span> lorem_ipsum_encoded)</span><span style="color:#bfbab0cc;">;
</span><span>                })</span><span style="color:#bfbab0cc;">;
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#f07178;">gen_benches!</span><span>(encode)</span><span style="color:#bfbab0cc;">;
</span><span style="color:#f07178;">gen_benches!</span><span>(encode_lookahead)</span><span style="color:#bfbab0cc;">;
</span></code></pre>
<p>This uses the first 4 paragraphs or so from <a href="https://lipsum.com/">Lorem Ipsum</a>, and on my machine the input buffering version is always faster:</p>
<pre style="background-color:#0f1419;color:#bfbab0;"><code><span> name       encode:: ns/iter  encode_lookahead:: ns/iter  diff ns/iter   diff %  speedup 
</span><span> encode_r1  4,243             3,745                               -498  -11.74%   x 1.13
</span></code></pre>
<h2 id="faster-decode">Faster decode</h2>
<p>Say we wanted to seriously speed up our decoding. We could do so by dropping the check of an unexpected zero. Why? Well if you drop that check, a zero marker will tell you exactly how many bytes you can copy over verbatim before the next marker. Which you can do in Rust with the <code>extend_from_slice</code> function, which is probably a bit faster than a manual loop. Let’s try that out:</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">pub fn </span><span style="color:#ffb454;">decode</span><span>(</span><span style="color:#f29718;">encoded_data</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span>[</span><span style="color:#ff7733;">u8</span><span>], </span><span style="color:#f29718;">decoded_data_buffer</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="color:#ff7733;">u8</span><span>&gt;) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="font-style:italic;color:#39bae6;">Result</span><span>&lt;</span><span style="color:#ff7733;">usize</span><span>, </span><span style="color:#ff7733;">usize</span><span>&gt; {
</span><span>    </span><span style="color:#ff7733;">if</span><span> encoded_data</span><span style="color:#f29668;">.</span><span style="color:#f07178;">len</span><span>() </span><span style="color:#f29668;">== </span><span style="color:#f29718;">0 </span><span>{
</span><span>        </span><span style="color:#ff7733;">return </span><span style="font-style:italic;color:#39bae6;">Err</span><span>(</span><span style="color:#f29718;">0</span><span>)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#ff7733;">let</span><span> start_length_out_buffer </span><span style="color:#f29668;">=</span><span> decoded_data_buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">len</span><span>()</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#ff7733;">let mut</span><span> index </span><span style="color:#f29668;">= </span><span style="color:#f29718;">0</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#ff7733;">let mut</span><span> zero_marker </span><span style="color:#f29668;">=</span><span> encoded_data[index] </span><span style="color:#f29668;">as </span><span style="color:#ff7733;">usize</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>    </span><span style="color:#ff7733;">loop </span><span>{
</span><span>        </span><span style="color:#ff7733;">let</span><span> next_index </span><span style="color:#f29668;">=</span><span> index </span><span style="color:#f29668;">+</span><span> zero_marker</span><span style="color:#bfbab0cc;">;
</span><span>        </span><span style="color:#ff7733;">if</span><span> zero_marker </span><span style="color:#f29668;">== </span><span style="color:#f29718;">0 </span><span>{
</span><span>            </span><span style="color:#ff7733;">return </span><span style="font-style:italic;color:#39bae6;">Ok</span><span>(decoded_data_buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">len</span><span>() </span><span style="color:#f29668;">-</span><span> start_length_out_buffer)</span><span style="color:#bfbab0cc;">;
</span><span>        }
</span><span>        </span><span style="color:#ff7733;">if</span><span> next_index </span><span style="color:#f29668;">&gt;=</span><span> encoded_data</span><span style="color:#f29668;">.</span><span style="color:#f07178;">len</span><span>() {
</span><span>            </span><span style="color:#ff7733;">return </span><span style="font-style:italic;color:#39bae6;">Err</span><span>(decoded_data_buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">len</span><span>() </span><span style="color:#f29668;">-</span><span> start_length_out_buffer)
</span><span>        }
</span><span>
</span><span>        decoded_data_buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">extend_from_slice</span><span>(</span><span style="color:#f29668;">&amp;</span><span>encoded_data[index</span><span style="color:#f29668;">+</span><span style="color:#f29718;">1</span><span style="color:#f29668;">..</span><span>next_index])</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>        </span><span style="color:#ff7733;">if</span><span> zero_marker </span><span style="color:#f29668;">!= </span><span style="color:#ff7733;">u8</span><span style="color:#f29668;">::</span><span>max_value() </span><span style="color:#f29668;">as </span><span style="color:#ff7733;">usize </span><span style="color:#f29668;">&amp;&amp;</span><span> encoded_data[next_index] </span><span style="color:#f29668;">!= </span><span style="color:#f29718;">0 </span><span>{
</span><span>            decoded_data_buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(</span><span style="color:#f29718;">0</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>        }
</span><span>
</span><span>        zero_marker </span><span style="color:#f29668;">=</span><span> encoded_data[next_index] </span><span style="color:#f29668;">as </span><span style="color:#ff7733;">usize</span><span style="color:#bfbab0cc;">;
</span><span>        index </span><span style="color:#f29668;">=</span><span> next_index</span><span style="color:#bfbab0cc;">;
</span><span>    }
</span><span>}
</span></code></pre>
<p>We don’t use iterators any more in this code. This is not very idiomatic for Rust, since Rust can more easily eliminate bounds checks for loops over iterators. However, we do get the <code>extend_from_slice</code> which is hopefully more efficient. So what we do is keep the index into the data around, and look up the zero marker. If the zero marker is zero, we’re done, end of message. If the index is out of bounds, that’s an error. Otherwise we extend from the <code>index+1</code> up to (not including) the next index. The <code>+1</code> is because <code>index</code> always points to a zeromarker. Should the zero marker be <code>255</code> or the next zero marker be <code>0</code>, then we don’t need to add a zero after the copied data. Then we update the zero marker and index.</p>
<p>To test this we run another benchmark, this time decoding the encoded lorem ipsum text. The results are quite promising:</p>
<pre style="background-color:#0f1419;color:#bfbab0;"><code><span> name       naive_decode:: ns/iter  decode:: ns/iter  diff ns/iter   diff %  speedup 
</span><span> decode_r1  3,962                   361                     -3,601  -90.89%  x 10.98
</span></code></pre>
<p>Naturally, this faster decode <em>is</em> too permissive. So a quickcheck test such as the following will fail most of the time by finding an incorrect COBS encoded message with an unexpected zero.</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span>    </span><span style="color:#f07178;">quickcheck! </span><span>{
</span><span>        </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">naive_decode_eq_decode</span><span>(</span><span style="color:#f29718;">data</span><span style="color:#bfbab0cc;">: </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="color:#ff7733;">u8</span><span>&gt;) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="color:#ff7733;">bool </span><span>{
</span><span>            </span><span style="color:#ff7733;">let mut</span><span> b1 </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">Vec</span><span style="color:#f29668;">::</span><span>new()</span><span style="color:#bfbab0cc;">;
</span><span>            </span><span style="color:#ff7733;">let mut</span><span> b2 </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">Vec</span><span style="color:#f29668;">::</span><span>new()</span><span style="color:#bfbab0cc;">;
</span><span>            </span><span style="color:#ff7733;">let</span><span> r1 </span><span style="color:#f29668;">= </span><span style="color:#f07178;">decode</span><span>(data</span><span style="color:#f29668;">.</span><span style="color:#f07178;">as_slice</span><span>()</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut</span><span> b1)</span><span style="color:#bfbab0cc;">;
</span><span>            </span><span style="color:#ff7733;">let</span><span> r2 </span><span style="color:#f29668;">= </span><span style="color:#f07178;">naive_decode</span><span>(data</span><span style="color:#f29668;">.</span><span style="color:#f07178;">as_slice</span><span>()</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut</span><span> b2)</span><span style="color:#bfbab0cc;">;
</span><span>            </span><span style="color:#ff7733;">if let </span><span>(</span><span style="font-style:italic;color:#39bae6;">Err</span><span>(</span><span style="color:#f29668;">_</span><span>)</span><span style="color:#bfbab0cc;">, </span><span style="font-style:italic;color:#39bae6;">Err</span><span>(</span><span style="color:#f29668;">_</span><span>)) </span><span style="color:#f29668;">= </span><span>(r1</span><span style="color:#bfbab0cc;">,</span><span>r2) {
</span><span>                </span><span style="color:#f29718;">true
</span><span>            } </span><span style="color:#ff7733;">else </span><span>{
</span><span>                r1 </span><span style="color:#f29668;">==</span><span> r2 </span><span style="color:#f29668;">&amp;&amp;</span><span> b1 </span><span style="color:#f29668;">==</span><span> b2
</span><span>            }
</span><span>        }
</span><span>    }
</span></code></pre>
<h2 id="faster-encode">Faster encode</h2>
<p>Perhaps we can also improve our look-ahead encoding, by not explicitly buffering anything. If instead we just find the position of the next zero, we can use some index juggling:</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">pub fn </span><span style="color:#ffb454;">encode_itertools</span><span>(</span><span style="color:#f29718;">data</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span>[</span><span style="color:#ff7733;">u8</span><span>], </span><span style="color:#f29718;">encoded_data_buffer</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="color:#ff7733;">u8</span><span>&gt;) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="color:#ff7733;">usize </span><span>{
</span><span>    </span><span style="color:#ff7733;">use </span><span>itertools</span><span style="color:#f29668;">::</span><span>Itertools</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>    </span><span style="color:#ff7733;">let</span><span> start_length_out_buffer </span><span style="color:#f29668;">=</span><span> encoded_data_buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">len</span><span>()</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#ff7733;">let mut</span><span> index </span><span style="color:#f29668;">= </span><span style="color:#f29718;">0_</span><span style="color:#ff7733;">usize</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#ff7733;">for</span><span> z_index </span><span style="color:#f29668;">in</span><span> data</span><span style="color:#f29668;">.</span><span style="color:#f07178;">iter</span><span>()</span><span style="color:#f29668;">.</span><span style="color:#f07178;">chain</span><span>(iter</span><span style="color:#f29668;">::</span><span>once(</span><span style="color:#f29668;">&amp;</span><span style="color:#f29718;">0</span><span>))</span><span style="color:#f29668;">.</span><span style="color:#f07178;">positions</span><span>(|</span><span style="color:#f29668;">&amp;</span><span style="color:#f29718;">b</span><span>| b </span><span style="color:#f29668;">== </span><span style="color:#f29718;">0</span><span>) {
</span><span>        </span><span style="color:#f07178;">debug_assert!</span><span>(z_index </span><span style="color:#f29668;">&gt;=</span><span> index)</span><span style="color:#bfbab0cc;">;
</span><span>        </span><span style="font-style:italic;color:#5c6773;">// index is always still-unvisited, so when z_index == index, we need to write a 1
</span><span>        </span><span style="color:#f07178;">macro_rules! </span><span style="color:#59c2ff;">offset_between_zeroes </span><span>{ () </span><span style="color:#f29668;">=&gt; </span><span>{z_index </span><span style="color:#f29668;">-</span><span> index </span><span style="color:#f29668;">+ </span><span style="color:#f29718;">1</span><span>}}
</span><span>        </span><span style="color:#ff7733;">while </span><span style="color:#f07178;">offset_between_zeroes!</span><span>() </span><span style="color:#f29668;">&gt;= </span><span style="color:#f29718;">MAX </span><span>{
</span><span>            encoded_data_buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(MAXu8)</span><span style="color:#bfbab0cc;">;
</span><span>            encoded_data_buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">extend_from_slice</span><span>(</span><span style="color:#f29668;">&amp;</span><span>data[index</span><span style="color:#f29668;">..</span><span>index </span><span style="color:#f29668;">+ </span><span style="color:#f29718;">MAX_CONSECUTIVE</span><span>])</span><span style="color:#bfbab0cc;">;
</span><span>            index </span><span style="color:#f29668;">+= </span><span style="color:#f29718;">MAX_CONSECUTIVE </span><span style="color:#f29668;">as </span><span style="color:#ff7733;">usize</span><span style="color:#bfbab0cc;">;
</span><span>        }
</span><span>        encoded_data_buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(</span><span style="color:#f07178;">offset_between_zeroes!</span><span>() </span><span style="color:#f29668;">as </span><span style="color:#ff7733;">u8</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>        encoded_data_buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">extend_from_slice</span><span>(</span><span style="color:#f29668;">&amp;</span><span>data[index</span><span style="color:#f29668;">..</span><span>z_index])</span><span style="color:#bfbab0cc;">;
</span><span>        index </span><span style="color:#f29668;">=</span><span> z_index </span><span style="color:#f29668;">+ </span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">;
</span><span>    }
</span><span>    encoded_data_buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(</span><span style="color:#f29718;">0</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>    encoded_data_buffer</span><span style="color:#f29668;">.</span><span style="color:#f07178;">len</span><span>() </span><span style="color:#f29668;">-</span><span> start_length_out_buffer
</span><span>}
</span></code></pre>
<p>We use <a href="https://crates.io/crates/itertools">itertools</a> here for the <code>positions</code> iterator method. We go over the whole data looking for the indices of the zero bytes. We’ve encoded up to <code>index</code>, so if the offset between there and the zero is too far, we need to add the special zero markers and the <code>MAX_CONSECUTIVE</code> number of data bytes. In the end we always write the offset as zero marker, then the data up to the zero, then set the index to <em>after</em> the zero.</p>
<p>This is again a bit faster because we don’t copy each byte into a buffer only to copy the buffer again. The positions iterator method now does the look-ahead for us.</p>
<pre style="background-color:#0f1419;color:#bfbab0;"><code><span> name       encode_lookahead:: ns/iter  encode_itertools:: ns/iter  diff ns/iter   diff %  speedup 
</span><span> encode_r1  3,750                       2,756                               -994  -26.51%   x 1.36
</span></code></pre>
<h1 id="conclusion">Conclusion</h1>
<p>So we’ve seen some Rust code today that was hopefully readable to you. Tests are easy because they’re built-in. Property based tests are just a crate import away. Benchmarks require the nightly compiler, but only those do, so you can just use <code>cargo +nightly bench</code> to run them. The comparison tables are generated with <a href="https://crates.io/crates/cargo-benchcmp"><code>cargo-benchcmp</code></a>.</p>
<p>I’ve shown some of my implementations for COBS in Rust, but this was only a learning exercise. I hope this inspires you to find a project of your own to get more experience with Rust. A <em>real</em> implementation of COBS in Rust can be found in the <a href="https://crates.io/crates/cobs"><code>cobs</code></a> crate, which allows you to use whichever sentinel value you want, can decode in-place, and doesn’t even use vectors so you can use the crate without the standard library.</p>
<hr><ol class="footnotes-list">
<li id="fn-overhead">
<p>If you count the zero at the end of a frame as part of the COBS algorithm, it has a minimum offset of 2. But apparently people usually count that as a separate “packetize” step, or so it says on Wikipedia. <a href="#fr-overhead-1">↩</a></p>
</li>
</ol>

  </main>
  <p>
  </p>
<footer>
    Made with <a href="https://codeberg.org/alanpearce/zola-bearblog">Zola ʕ•ᴥ•ʔ Bear</a>
</footer>
</body>
</html>
