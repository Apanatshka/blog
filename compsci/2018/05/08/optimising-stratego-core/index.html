<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>Optimising CTree and strs</title>
    <meta name="description" content="A web log. Mostly about computer science-y stuff. 
">

    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="https://blog.jeffsmits.net/compsci/2018/05/08/optimising-stratego-core/">
    
    <link rel="stylesheet" type="text/css" href="/css/katex.min.css">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Whatever</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Optimising CTree and strs</h1>
    <p class="post-meta">May 8, 2018</p>
  </header>

  <article class="post-content">
    <p>Once upon a time, I wrote an <a href="/compsci/2017/08/06/a-stratego-interpreter-in-rust/">interpreter for Stratego Core</a> in Rust, which I named <code class="highlighter-rouge">strs</code>. Stratego Core is the core language that Stratego is compiled to before the compiler goes further (to Java, or previously to C). A core language is an intermediate representation that is a subset of the surface language.</p>

<p>While I optimised that interpreter quite a bit, I noticed that the CTree (Stratego Core Abstract Syntax Tree) that the compiler spit out for me to interpret was very unoptimised. Therefore one the plans I described at the end of the blog post was a little tool for Copy Propagation on CTree files. This post is about that tool, and the optimisations in the interpreter that made it obsolete again.</p>

<h1 id="copy-propagation">Copy Propagation</h1>

<p>Copy propagation looks for assignments of one variable to the value of another variable, and inline that assignment. So for a program with <code class="highlighter-rouge">x = y</code>, copy propagation will eliminate that assignment and instead replace subsequent uses of <code class="highlighter-rouge">x</code> with <code class="highlighter-rouge">y</code>. When Stratego is translated to Stratego Core, the syntactic sugar is removed by introducing lots of new variables. Copy propagation is a good clean-up optimisation to remove many superfluous assignments that result from the desugaring. Of course this simple idea is not so simple in Stratego…</p>

<h2 id="copy-propagation-for-stratego">Copy Propagation for Stratego</h2>

<p>Here’s a really short refresher, look at the <a href="/compsci/2017/08/06/a-stratego-interpreter-in-rust/"><code class="highlighter-rouge">strs</code> blog post</a> if you need more. In Stratego Core we have a current term. There are term variable and strategy variables, new ones can be introduced with scopes and lets respectively. We can match against the current term, and we can build another term in its place, where both use patterns that can have term variables in them. We can call strategies and primitives. There are generic traversals over terms, basic <code class="highlighter-rouge">id</code> and <code class="highlighter-rouge">fail</code> strategies, and the guarded choice as a kind of if-then-else.</p>

<p>An assignment in Stratego Core can be found when you match the current term against a pattern. What we’re looking for in particular is building a plain variable, then matching another plain variable (no more complicated patterns). However, matching against a variable that already has a bound value is <em>not</em> an assignment. Then the meaning is an equality test. So we can’t just look in a sequence of strategies for a <code class="highlighter-rouge">..., Build(Var(...)), Match(Var(...)), ...</code>, we need to check whether the match is actually a binding of a fresh variable. The simplest way I know to do so is by adapting the interpreter we had, to instead to an “abstract interpretation”.</p>

<h1 id="copy-prop-on-ctree-using-abstract-interpretation">Copy prop on CTree using abstract interpretation</h1>

<p>Abstract interpretation is a way of using an interpreter for static analysis of a program. The abstract part is usually about the values of variables, where you choosing some more vague, a property, instead of a real value. That way you can analyse the program without needing input or user interaction. Ideally you also figure out a value space or some other way to make sure you can’t go into loops, so your analysis actually terminates (and does so within a reasonable amount of time).</p>

<p>The term abstract interpretation is used in academia for something more sophisticated: given an interpreter, make systematic changes that provably preserve the semantics of the interpreter, while abstracting it. This way you can design an analysis of a program that provably abstracts over the concrete semantics of the program as given by the original interpreter. This is not an easy topic to read about, and until a <a href="http://svenkeidel.de/">fellow PhD student</a> started working on it, I was convinced that it’s also not easy to execute. I wish I could link you to his publication but it’s still under review.</p>

<h2 id="values">Values</h2>

<p>So let’s set up an interpreter that always terminates by not going into strategy calls. The value space, which would also be the value for the current term, should be a “yes-no-maybe” kind of value:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="n">CTreeOptimize</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Context</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">optimize</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">Self</span><span class="p">::</span><span class="n">Context</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span><span class="p">;</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Hash,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
<span class="k">enum</span> <span class="n">Value</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">UnBound</span><span class="p">,</span>
    <span class="n">MaybeBound</span><span class="p">,</span>
    <span class="n">Bound</span><span class="p">,</span>
    <span class="nf">BoundTo</span><span class="p">(</span><span class="n">InternedString</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span> <span class="n">Value</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">lub</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="k">use</span> <span class="k">self</span><span class="p">::</span><span class="nn">Value</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

        <span class="k">if</span> <span class="k">self</span> <span class="o">==</span> <span class="n">other</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">self</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">match</span> <span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">(</span><span class="o">&amp;</span><span class="nf">BoundTo</span><span class="p">(</span><span class="n">_</span><span class="p">),</span> <span class="o">&amp;</span><span class="nf">BoundTo</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="p">|</span>
            <span class="p">(</span><span class="o">&amp;</span><span class="nf">BoundTo</span><span class="p">(</span><span class="n">_</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">Bound</span><span class="p">)</span> <span class="p">|</span>
            <span class="p">(</span><span class="o">&amp;</span><span class="n">Bound</span><span class="p">,</span> <span class="o">&amp;</span><span class="nf">BoundTo</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="n">Bound</span><span class="p">,</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="n">MaybeBound</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span> <span class="n">PartialOrd</span><span class="o">&lt;</span><span class="n">Value</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;&gt;</span> <span class="k">for</span> <span class="n">Value</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c">// a &lt;= b iff lub(a,b) == b</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
<span class="k">struct</span> <span class="n">Scope</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">strategy</span><span class="p">:</span> <span class="n">FnvHashMap</span><span class="o">&lt;</span>
        <span class="n">InternedString</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="p">(::</span><span class="nn">std</span><span class="p">::</span><span class="nn">result</span><span class="p">::</span><span class="n">Result</span><span class="o">&lt;</span><span class="n">FnvHashSet</span><span class="o">&lt;</span><span class="n">InternedString</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">DynamicCall</span><span class="o">&gt;</span><span class="p">,</span>
         <span class="nb">usize</span><span class="p">),</span>
    <span class="o">&gt;</span><span class="p">,</span>
    <span class="n">term</span><span class="p">:</span> <span class="n">FnvHashMap</span><span class="o">&lt;</span><span class="n">InternedString</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Value</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">is_overlay</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">is_unbound_overlay</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can define our interpreter using the <code class="highlighter-rouge">CTreeOptimize</code> trait, which just goes over the tree, since we’re not following strategy calls. The <code class="highlighter-rouge">Context</code> is different depending on if we’re in a strategy or outside of it. Inside there’s the current term and the stack of scopes, outside the context is <code class="highlighter-rouge">()</code>. The values of variable can at most record that they’re bound to the value of another variable. The partial order is:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      MaybeBound
     /          \
UnBound        Bound
              /  |  \
BoundTo("a_1")  ...  BoundTo("z_999")
</code></pre></div></div>

<p>The Least-Upper-Bound (<code class="highlighter-rouge">lub</code>) operation gives a conservative combination of values when you need to merge values from multiple branches of execution (guarded choice).</p>

<h2 id="match-and-build">Match and Build</h2>

<p>The context <code class="highlighter-rouge">c</code> in the next snippet is a tuple of the current term and the scopes stack. So we set <code class="highlighter-rouge">c.0</code> to change the current term, and do lookups in <code class="highlighter-rouge">c.1</code> for the term variables. The current term is an option of the name of the variable that was built previously. With <code class="highlighter-rouge">into</code> it’s turned into <code class="highlighter-rouge">Bound</code> or <code class="highlighter-rouge">BoundTo(_)</code> depending on whether it’s <code class="highlighter-rouge">None</code> or <code class="highlighter-rouge">Some(_)</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">Strategy</span><span class="p">::</span><span class="nf">Match</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
    <span class="c">// If we match against a single variable...</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nn">MatchTerm</span><span class="p">::</span><span class="nf">Var</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="n">mt</span> <span class="p">{</span>
        <span class="c">// ...and it's guaranteed to be UnBound at this point...</span>
        <span class="k">if</span> <span class="n">c</span><span class="err">.</span><span class="mi">1</span><span class="nf">.get_term</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Value</span><span class="p">::</span><span class="n">UnBound</span><span class="p">)</span> <span class="p">{</span>
            <span class="c">// ...we set the name to be bound to what the current value is</span>
            <span class="n">c</span><span class="err">.</span><span class="mi">1</span><span class="nf">.set_term</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="err">.</span><span class="mi">0</span><span class="p">)</span><span class="nf">.into</span><span class="p">());</span>
            <span class="c">// if the current value is also a known binding, we've found an alias</span>
            <span class="c">//  that we can eliminate</span>
            <span class="k">if</span> <span class="n">c</span><span class="err">.</span><span class="mi">0</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nn">Strategy</span><span class="p">::</span><span class="n">Id</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c">// Otherwise the current is now a known binding</span>
                <span class="n">c</span><span class="err">.</span><span class="mi">0</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c">// We optimize match patterns by replacing variables when they are aliases</span>
    <span class="nn">Strategy</span><span class="p">::</span><span class="nf">Match</span><span class="p">(</span><span class="n">mt</span><span class="nf">.optimize</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
<span class="p">}</span>
<span class="nn">Strategy</span><span class="p">::</span><span class="nf">Build</span><span class="p">(</span><span class="n">bt</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
    <span class="c">// We optimize build patterns by replacing variables when they are aliases</span>
    <span class="k">let</span> <span class="n">bt</span> <span class="o">=</span> <span class="n">bt</span><span class="nf">.optimize</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="c">// If we build a single variable...</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nn">BuildTerm</span><span class="p">::</span><span class="nf">Var</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="n">bt</span> <span class="p">{</span>
        <span class="c">// ...and the variable is guaranteed to be bound at this point</span>
        <span class="k">match</span> <span class="n">c</span><span class="err">.</span><span class="mi">1</span><span class="nf">.get_term</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="nn">Value</span><span class="p">::</span><span class="n">Bound</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="c">// ...we record that the current term is also this known binding</span>
                <span class="n">c</span><span class="err">.</span><span class="mi">0</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
                <span class="k">return</span> <span class="nn">Strategy</span><span class="p">::</span><span class="nf">Build</span><span class="p">(</span><span class="n">bt</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="c">// Note that we don't need to handle BoundTo because that would have</span>
            <span class="c">//  been an alias that was replaced by the optimize call on the pattern</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c">// If the build is not a single variable or a possibly unbound variable, we</span>
    <span class="c">//  don't know for sure if the current term is also known as a variable</span>
    <span class="n">c</span><span class="err">.</span><span class="mi">0</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
    <span class="nn">Strategy</span><span class="p">::</span><span class="nf">Build</span><span class="p">(</span><span class="n">bt</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="scopes-and-sequences">Scopes and Sequences</h2>

<p>For a Stratego Core scope construct we introduce a scope to the stack of scopes, optimize the strategy in the scope, then pop the scope again. From this scope we can learn which variables were bound to another variable and therefore removed, so we also remove them from the list of fresh variables as they are no longer used.</p>

<p>For sequences we do something more than just optimise the strategies in it. Since optimised single variable matches are turned into <code class="highlighter-rouge">id</code> strategies, we can just filter all <code class="highlighter-rouge">id</code> strategies in a sequence to get rid of that. While we’re at it, we can also cut the sequence short if we run into a <code class="highlighter-rouge">fail</code>. Lastly, when we find a sequence of builds, where the first build has all bound variables, therefore it is guaranteed to succeed, then we remove that build, since the second build will immediately override the current term value. These are all patterns that I noticed while scrolling through some CTree files that the compiler spit out.</p>

<h1 id="results-of-applying-ctree_opt">Results of applying <code class="highlighter-rouge">ctree_opt</code></h1>

<p>In the previous <code class="highlighter-rouge">strs</code> post I benchmarked against a <code class="highlighter-rouge">benchexpr10</code> and a <code class="highlighter-rouge">benchexpr20</code> program. The first takes a very short time, the second a fairly long one. So I created a <code class="highlighter-rouge">benchexpr15</code>, which was easy enough. The ctree of that program is <code class="highlighter-rouge">62221 B</code>. The optimised version with <code class="highlighter-rouge">ctree_opt</code> is <code class="highlighter-rouge">58003 B</code>, an almost 7% decrease in file size.</p>

<p>Now, when we run the benchmark, and the optimised version, we get the timings:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>strs benchexpr15.ctree       3.25s user 0.04s system 99% cpu 3.317 total
strs benchexpr15.opt.ctree   3.13s user 0.06s system 99% cpu 3.223 total
</code></pre></div></div>

<p>Consistently 3% faster with optimisation.</p>

<h1 id="making-name-lookup-cheap">Making name lookup cheap</h1>

<p>The <code class="highlighter-rouge">ctree_opt</code> tool really didn’t do much more than remove some redundant matches and builds. Given the improvement on the benchmark, that suggests that there might be something wrong with variable lookup. If we look at the interpreter, it has a stack of scopes. Each scope has a hashmap from variable name to value (or <code class="highlighter-rouge">None</code> if unbound). The interpreter looks up the name by trying each hashmap while going down the stack.</p>

<p>We could instead keep a hashmap of value stacks, but this would make pushing and popping scopes much more expensive. We could keep around a hashmap of name to offset in the stack of scopes with much the same problem. We could also run a static analysis to find the nearest scope that defines the term variable and save the offset to that scope for each variable.</p>

<p>If we’re speaking of offsets anyway, why not use offsets within a scope too, so we don’t need the hashmap lookup anymore? To really go off the rails here, we can fuse all the scopes into one big vector (we know their sizes statically), as long as we dynamically keep track of at which index a scope began. Now we have one vector of values, and a complicated calculation of offsets. You can guess the result: off-by-one errors. And slow interpreter startup, as the offset calculation of all names (term and strategy) are done at startup for the entire program + libraries.</p>

<p>For the slow startup there was a quick-and-dirty solution: Use strategy names, starting from main, and check strategy reachability to do course-grained dead-code elimination. Most of the standard library isn’t used anyway. For the off-by-one errors, only time and patience could fix the problems. In the end I got it working almost completely, at least complete enough to run the benchmark successfully again:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>strs benchexpr15.ctree       2.36s user 0.05s system 99% cpu 2.423 total
strs benchexpr15.opt.ctree   2.34s user 0.04s system 99% cpu 2.396 total
</code></pre></div></div>

<p>Optimisation seems to have a positive effect still, but now it falls within the run-to-run variance.</p>

<p>So there you have it. A CTree optimisation tool with abstract interpretation, and a slightly crazy scheme to model the stack memory of the interpreter with a single vector. Not that that’s completely working yet, and I haven’t had time to fix the last issues for a while now, but such is the fate of my side-projects constantly. So I’ll just close with: meh, whatever ¯\_(ツ)_/¯</p>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Whatever</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li><a href="mailto:jeff.smits@gmail.com">jeff.smits@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/Apanatshka">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">Apanatshka</span>
            </a>
          </li>
          

          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">A web log. Mostly about computer science-y stuff. 
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
