<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>Learn Rust by project</title>
    <meta name="description" content="A web log. Mostly about computer science-y stuff. 
">

    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="http://blog.jeffsmits.net/compsci/2018/04/30/learn-rust-by-project/">
    
    <link rel="stylesheet" type="text/css" href="/css/katex.min.css">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Whatever</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Learn Rust by project</h1>
    <p class="post-meta">Apr 30, 2018</p>
  </header>

  <article class="post-content">
    <p>More than a year ago a friend of mine wanted to learn a bit more about Rust by trying out a project. He had a nice project in mind which suits Rust quite well I think. For fun I joined his effort and created <a href="https://gitlab.com/Apanatshka/cobs">an implementation</a> at the same time as he did, discussing and comparing along the way. In this post I’ll tell you about the project specifics, but the point of the post is more an encouragement. If you’ve read about Rust before but haven’t tried it yet, find a small project like the one below, and learn Rust in a fun and hands-on way yourself. It’s a great programming language, I highly recommend it.</p>

<h1 id="the-project-consistent-overhead-byte-stuffing">The project: consistent overhead byte stuffing</h1>

<p>Computer networking can be messy business. Depending on what <a href="https://en.wikipedia.org/wiki/OSI_model#Description_of_OSI_layers">layer of the network</a> your software is operating in, you need to worry about different kinds of errors. If you’re receiving raw bytes, you might run into the issue of corrupted messages. You could throw away such a message entirely… Or you could try to chop it into chunks with a clear boundary and recover at the next boundary.</p>

<p>Byte stuffing is the process of stuffing bytes into a smaller range of values than the full byte, so you can use the unused values for something special like the boundaries of messages. The usual terminology is splitting your bytes of data into <em>frames</em> and using <em>sentinel values</em> to delimit the frames.</p>

<p>The problem that byte stuffing solves then, is what to do with values in your data that are the sentinel value you picked for delimiting frames. These should be turned into something else that can be reliably decoded again. The project of this post is to implement an algorithm for Consistent Overhead Byte Stuffing, or COBS. This algorithm has an overhead of at least one byte and at most one byte in 254 rounded up. If I’d been presented with this problem myself before I’d heard of COBS, I would have probably done something like pick two byte values, one delimiter and one “escape character”. The worst case for that is something like twice the size of the message. So this algorithm is pretty cool. I’ll explain it in my own words, but the <a href="https://en.wikipedia.org/wiki/Consistent_Overhead_Byte_Stuffing">Wikipedia article</a> is very nice too, so browse that if you don’t follow everything here.</p>

<h1 id="cobs-in-short">COBS in short</h1>

<p>Let’s choose zero as our sentinel values, our <em>frame marker</em>. If we need to recover from some error in the middle of the stream of frames, we just look for the next zero, that’s the end of a frame. Then the first byte is our consistent minimum overhead byte, which starts the COBS encoding. This byte tells us the offset to where the next zero should have been in the message. Until that offset is reached, the bytes should be the original message. If in those bytes you find a zero, the message is definitely corrupted and you should skip to the next frame. Once you reach the offset, instead of a zero you should find another number, which is the offset from there to the next zero in the original message. So each zero is turned into a higher number of where the next zero is. The last zero points to the place where the zero of the end of the frame should be<sup id="fnref:overhead"><a href="#fn:overhead" class="footnote">1</a></sup>.</p>

<p>Let’s call these offsets to a zero <em>zero markers</em>. The first <em>zero marker</em> is <em>fake</em>, since it doesn’t mark a zero at its place. We need it to point out the first actual zero. There can be more fake zero markers in the message, and this is where the worst case overhead comes from: what if two zeroes are further apart than the size of a byte? Assuming we’re speaking of <a href="https://en.wikipedia.org/wiki/Octet_(computing)">octets</a>, which is usually the case these days, we have 0-255 as the normal value range. We’re changing that range to 1-255. So if 255 is the maximum value for our zero marker, we cannot have more than 254 consecutive non-zero bytes. To fix this we say that zero markers with value 255 signify that the <em>next</em> zero marker is <em>fake</em>. Again, a fake zero marker does not signify a zero, but just how many bytes to read until we reach the next zero marker.</p>

<h1 id="cobs-in-rust">COBS in Rust</h1>

<p>Now that we’ve seen a prose description of COBS in Rust, let’s implement an encode and a decode function for COBS. In this case I’ll present an implementation that is uses a sentinel value of zero, adds that zero as part of the encode procedure, and expects it during decode. Note that this is not going to be the most beautiful implementation possible. We’re not using traits from Rust’s standard library, such as <code class="highlighter-rouge">Read</code> and <code class="highlighter-rouge">Write</code> even though these work with bytes. We’re hard-coding the sentinel value to <code class="highlighter-rouge">0</code>.</p>

<h2 id="tests">Tests</h2>

<p>To start things off, let’s define the types for encode and decode, and then write some tests to make our understanding of the algorithm executable. We start out with some unit tests, and some property based tests using <a href="https://crates.io/crates/quickcheck">quickcheck</a>. Property based tests use a function from some input to boolean and given that input check if a property holds.</p>

<p>With the property based tests we check that encoding and decoding a given vector of bytes comes to the same thing. The quickcheck framework then generates some random vectors of bytes and checks if our property holds. If it doesn’t, the framework shrinks the counter example with some heuristics. It’s pretty cool stuff. I recommend using this form of testing whenever you can.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">//! Consistent overhead byte stuffing</span>
<span class="c">//! =================================</span>
<span class="c">//!</span>
<span class="c">//! This encoding allows for packet loss in a stream of bytes by dividing data into frames.</span>
<span class="c">//!</span>
<span class="c">//! 0 = framemarker, the thing you search for when you recover in the middle of a stream. It marks</span>
<span class="c">//!  the end of a frame.</span>
<span class="c">//! Zeromarkers both mark a zero and have a value of where the next zeromarker is. There are also</span>
<span class="c">//! special zeromarkers, which say the next zeromarker is fake. Fake zeromarkers don't mark zeroes,</span>
<span class="c">//! they only tell where the next zeromarker is.</span>
<span class="c">//! The first byte of a frame is a fake zeromarker.</span>
<span class="c">//! Other bytes are normal bytes.</span>
<span class="c">//! When normally (in the original data) the next zero occurs, this is another zeromarker. The</span>
<span class="c">//!  first (fake) zeromarker will have the offset after which the next zeromarker occurs.</span>
<span class="c">//! The special zeromarker 255 predicts that the next zeromarker is fake. The reason for calling it</span>
<span class="c">//! fake is to support data where the are more than 255 bytes between zeroes.</span>

<span class="nd">#[cfg(test)]</span>
<span class="nd">#[macro_use]</span>
<span class="k">extern</span> <span class="n">crate</span> <span class="n">quickcheck</span><span class="p">;</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">iter</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">encode</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">encoded_data_buffer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="nd">unimplemented!</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">decode</span><span class="p">(</span><span class="n">encoded_data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">decoded_data_buffer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">unimplemented!</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">max_encoded_size</span><span class="p">(</span><span class="n">input_size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">input_size</span> <span class="o">*</span> <span class="p">(</span><span class="nn">u8</span><span class="p">::</span><span class="nf">max_value</span><span class="p">()</span> <span class="k">as</span> <span class="nb">f32</span> <span class="err">/</span> <span class="p">(</span><span class="nn">u8</span><span class="p">::</span><span class="nf">max_value</span><span class="p">()</span> <span class="err">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="nb">f32</span><span class="p">)</span><span class="nf">.ceil</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">+</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">max_decoded_size</span><span class="p">(</span><span class="n">encoded_size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">encoded_size</span> <span class="err">-</span> <span class="mi">2</span>
<span class="p">}</span>

<span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="nd">macro_rules!</span> <span class="n">unit_test_set</span> <span class="p">{</span>
        <span class="p">(</span><span class="nv">$assert:path</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">#[test]</span>
            <span class="k">fn</span> <span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
                <span class="nv">$assert</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[],</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span>
            <span class="p">}</span>

            <span class="nd">#[test]</span>
            <span class="k">fn</span> <span class="nf">zero</span><span class="p">()</span> <span class="p">{</span>
                <span class="nv">$assert</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span>
            <span class="p">}</span>

            <span class="nd">#[test]</span>
            <span class="k">fn</span> <span class="nf">one</span><span class="p">()</span> <span class="p">{</span>
                <span class="nv">$assert</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span>
            <span class="p">}</span>

            <span class="nd">#[test]</span>
            <span class="k">fn</span> <span class="nf">byte_max</span><span class="p">()</span> <span class="p">{</span>
                <span class="nv">$assert</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mi">255</span><span class="p">],</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span>
            <span class="p">}</span>

            <span class="nd">#[test]</span>
            <span class="k">fn</span> <span class="nf">five_zeroes</span><span class="p">()</span> <span class="p">{</span>
                <span class="nv">$assert</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">5</span><span class="p">],</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span>
            <span class="p">}</span>

            <span class="nd">#[test]</span>
            <span class="k">fn</span> <span class="nf">five_ones</span><span class="p">()</span> <span class="p">{</span>
                <span class="nv">$assert</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">5</span><span class="p">],</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span>
            <span class="p">}</span>

            <span class="nd">#[test]</span>
            <span class="k">fn</span> <span class="nf">byte_max_zeroes</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">output</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="mi">257</span><span class="p">);</span>
                <span class="n">output</span><span class="nf">.extend_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">256</span><span class="p">]);</span>
                <span class="n">output</span><span class="nf">.push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
                <span class="nv">$assert</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">255</span><span class="p">],</span> <span class="n">output</span><span class="nf">.as_slice</span><span class="p">());</span>
            <span class="p">}</span>

            <span class="nd">#[test]</span>
            <span class="k">fn</span> <span class="nf">byte_max_ones</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">output</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="mi">258</span><span class="p">);</span>
                <span class="n">output</span><span class="nf">.push</span><span class="p">(</span><span class="mi">255</span><span class="p">);</span>
                <span class="n">output</span><span class="nf">.extend_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">254</span><span class="p">]);</span>
                <span class="n">output</span><span class="nf">.extend_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span>
                <span class="nv">$assert</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">255</span><span class="p">],</span> <span class="n">output</span><span class="nf">.as_slice</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">mod</span> <span class="n">encode</span> <span class="p">{</span>
        <span class="k">use</span> <span class="nn">super</span><span class="p">::</span><span class="nn">super</span><span class="p">::</span><span class="n">encode</span><span class="p">;</span>

        <span class="k">fn</span> <span class="nf">check_encoded_vs_given</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">encoded</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="nf">encode</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">buffer</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">encoded</span><span class="p">,</span> <span class="n">buffer</span><span class="nf">.as_slice</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="nd">unit_test_set!</span><span class="p">(</span><span class="n">check_encoded_vs_given</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">mod</span> <span class="n">decode</span> <span class="p">{</span>
        <span class="k">use</span> <span class="nn">super</span><span class="p">::</span><span class="nn">super</span><span class="p">::</span><span class="n">decode</span><span class="p">;</span>

        <span class="k">fn</span> <span class="nf">check_decoded_vs_given</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">encoded</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="nf">decode</span><span class="p">(</span><span class="n">encoded</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">buffer</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">buffer</span><span class="nf">.as_slice</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="nd">unit_test_set!</span><span class="p">(</span><span class="n">check_decoded_vs_given</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">use</span> <span class="nn">super</span><span class="p">::{</span><span class="n">encode</span><span class="p">,</span> <span class="n">decode</span><span class="p">};</span>

    <span class="nd">quickcheck!</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">encode_decode_identity</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">b1</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">b2</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="nf">encode</span><span class="p">(</span><span class="n">data</span><span class="nf">.as_slice</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">b1</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="nf">decode</span><span class="p">(</span><span class="n">b1</span><span class="nf">.as_slice</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">b2</span><span class="p">);</span>
            <span class="n">data</span> <span class="o">==</span> <span class="n">b2</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="constants">Constants</h2>

<p>I really dislike magic values in my code. Here are some constants we’ll use:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">MAXu8</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="nn">u8</span><span class="p">::</span><span class="nf">max_value</span><span class="p">();</span>
<span class="k">const</span> <span class="n">MAX</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">MAXu8</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
<span class="k">const</span> <span class="n">MAX_CONSECUTIVE</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">MAX</span> <span class="err">-</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">MAX*</code> values are just shorter without using <code class="highlighter-rouge">255</code> literally. I did use them in the tests because there are related numbers off by 2 or 3. It made more sense in the unit tests, which encode specific examples. The code is abstract, should work for any case.</p>

<h2 id="decode">Decode</h2>

<p>So let’s decode some bytes. For every byte we can either interpret it as a zero marker if it’s at the right offset, or we can copy the byte to the output verbatim. If the copied byte is zero, that’s an error. Unless it’s a predicted zero marker, in which case we’re successfully finished. If it’s a zero marker that’s not fake, we push a zero instead of the byte value of the marker. We also need to compute the index of the next zero marker with the relative offset. This boils down to the following code:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">decode</span><span class="p">(</span><span class="n">encoded_data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span>
              <span class="n">decoded_data_buffer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span>
              <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">zero_marker_index</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">fake</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">byte</span><span class="p">)</span> <span class="n">in</span> <span class="n">encoded_data</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="n">zero_marker_index</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">byte</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">written</span><span class="p">);</span> <span class="c">// framemarker, we're done</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="o">!</span><span class="n">fake</span> <span class="p">{</span>
                <span class="n">decoded_data_buffer</span><span class="nf">.push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
                <span class="n">written</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">zero_marker_index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="n">byte</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
            <span class="n">fake</span> <span class="o">=</span> <span class="n">byte</span> <span class="o">==</span> <span class="n">MAXu8</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">byte</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span> <span class="c">// fail</span>
            <span class="p">}</span>
            <span class="n">decoded_data_buffer</span><span class="nf">.push</span><span class="p">(</span><span class="n">byte</span><span class="p">);</span>
            <span class="n">written</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">Err</span><span class="p">(</span><span class="n">written</span><span class="p">)</span> <span class="c">// fail</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">zero_marker_index</code> is the absolute offset from the start of the <code class="highlighter-rouge">encoded_data</code> slice. The boolean <code class="highlighter-rouge">fake</code> is for remembering if that zero marker will be fake or not. We also track how many bytes we’ve <code class="highlighter-rouge">written</code> in the buffer of decoded data. We break from the loop to fail, because we may also find no <code class="highlighter-rouge">0</code> at all and run out of encoded data, which is also a corner case where we should fail.</p>

<h2 id="encode-buffer-input">Encode (buffer input)</h2>

<p>There are two different ways you can implement COBS. One is to look ahead in the data for the zero. This means to need a buffer of 254 bytes at most, but you can sequentially output the encoded bytes. Is to sequentially read the input byte without buffering them, instead buffering the output so you can go back and fill in the space you reserved for the zero marker once you’ve seen the next zero. Let’s first look at the look-ahead version:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">encode_lookahead</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">encoded_data_buffer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">start_length_out_buffer</span> <span class="o">=</span> <span class="n">encoded_data_buffer</span><span class="nf">.len</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">data_iter</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.chain</span><span class="p">(</span><span class="nn">iter</span><span class="p">::</span><span class="nf">once</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0</span><span class="p">))</span><span class="nf">.peekable</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="n">_u8</span><span class="p">;</span> <span class="n">MAX_CONSECUTIVE</span><span class="p">];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">buf_index</span><span class="p">:</span> <span class="nb">usize</span><span class="p">;</span>

    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">data_iter</span><span class="nf">.peek</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">buf_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="c">// Find the next zero, copy bytes seen into buffer</span>
        <span class="k">for</span> <span class="o">&amp;</span><span class="n">byte</span> <span class="n">in</span> <span class="n">data_iter</span><span class="nf">.by_ref</span><span class="p">()</span><span class="nf">.take_while</span><span class="p">(|</span><span class="o">&amp;&amp;</span><span class="n">b</span><span class="p">|</span> <span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">buf</span><span class="p">[</span><span class="n">buf_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">byte</span><span class="p">;</span>
            <span class="n">buf_index</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">buf_index</span> <span class="o">&lt;=</span> <span class="n">buf</span><span class="nf">.len</span><span class="p">());</span>
            <span class="k">if</span> <span class="n">buf_index</span> <span class="o">==</span> <span class="n">buf</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c">// Write where next zero is, then write the data from the buffer</span>
        <span class="c">// Note the +1, since buf_index starts at zero and the next zero is always at least one away</span>
        <span class="n">encoded_data_buffer</span><span class="nf">.push</span><span class="p">(</span><span class="n">buf_index</span> <span class="k">as</span> <span class="nb">u8</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">encoded_data_buffer</span><span class="nf">.extend_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">buf_index</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">encoded_data_buffer</span><span class="nf">.push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="n">encoded_data_buffer</span><span class="nf">.len</span><span class="p">()</span> <span class="err">-</span> <span class="n">start_length_out_buffer</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Given that we take in some <code class="highlighter-rouge">Vec&lt;u8&gt;</code> that we append to, we should save the length and return the difference in length as the amount of bytes written. Then we create an iterator over the data, followed by an extra zero, which should be <code class="highlighter-rouge">peekable</code>. This means we can look ahead without consuming to see if the iterator is done yet. While it isn’t done, we set keep an index of the used part of the buffer. For the bytes in the iterator, we just add them to the buffer unless it’s a zero or the buffer is full. Then we write the zero marker first using the buffer index to see how many non-zeroes we found ahead. And we copy over the buffer. The extra zero on the data iterator compensates for the extra zero-marker at the front of the message. The extra zero pushed at the end ends the message.</p>

<h2 id="encode-buffer-output">Encode (buffer output)</h2>

<p>If we buffer the output, we can just write a bogus value for the zero marker, remember its index, and overwrite it later. Again only 255 bytes need to be buffered at a maximum, although this isn’t visible in our implementation.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">encode</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">encoded_data_buffer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">start_length_out_buffer</span> <span class="o">=</span> <span class="n">encoded_data_buffer</span><span class="nf">.len</span><span class="p">();</span>

    <span class="c">// Note that we always start from 1, so we count MAX_CONSEQUTIVE bytes of non-zero data</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">non_zero_count</span> <span class="o">=</span> <span class="mi">1</span><span class="n">_usize</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">zero_marker_index</span><span class="p">;</span>

    <span class="nd">macro_rules!</span> <span class="n">next_zero_marker</span> <span class="p">{</span> <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="n">encoded_data_buffer</span><span class="p">[</span><span class="n">zero_marker_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">non_zero_count</span> <span class="k">as</span> <span class="nb">u8</span><span class="p">;</span>
        <span class="n">non_zero_count</span> <span class="o">=</span> <span class="mi">1</span><span class="n">_usize</span><span class="p">;</span>
        <span class="n">zero_marker_index</span> <span class="o">=</span> <span class="n">encoded_data_buffer</span><span class="nf">.len</span><span class="p">();</span>
        <span class="n">encoded_data_buffer</span><span class="nf">.push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}};</span>
    <span class="n">zero_marker_index</span> <span class="o">=</span> <span class="n">encoded_data_buffer</span><span class="nf">.len</span><span class="p">();</span>
    <span class="n">encoded_data_buffer</span><span class="nf">.push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="c">// NOTE: the extra zero at the end will become the framemarker</span>
    <span class="k">for</span> <span class="o">&amp;</span><span class="n">byte</span> <span class="n">in</span> <span class="n">data</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.chain</span><span class="p">(</span><span class="nn">iter</span><span class="p">::</span><span class="nf">once</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">byte</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nd">next_zero_marker!</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">encoded_data_buffer</span><span class="nf">.push</span><span class="p">(</span><span class="n">byte</span><span class="p">);</span>
            <span class="n">non_zero_count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">non_zero_count</span> <span class="o">&lt;=</span> <span class="n">MAX</span><span class="p">);</span>
            <span class="k">if</span> <span class="n">non_zero_count</span> <span class="o">==</span> <span class="n">MAX</span> <span class="p">{</span>
                <span class="nd">next_zero_marker!</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">encoded_data_buffer</span><span class="nf">.len</span><span class="p">()</span> <span class="err">-</span> <span class="n">start_length_out_buffer</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In the end, I don’t think the memory requirements and timing behaviour of the two different options should be very different. But to put that to the test, I’ve written a little benchmark:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">gen_benches</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$prefix:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">mod</span> <span class="nv">$prefix</span> <span class="p">{</span>
            <span class="k">use</span> <span class="nn">test</span><span class="p">::</span><span class="n">Bencher</span><span class="p">;</span>
            <span class="k">use</span> <span class="nn">cobs</span><span class="p">::</span><span class="nv">$prefix</span><span class="p">;</span>
            <span class="k">use</span> <span class="nn">super</span><span class="p">::</span><span class="n">LOREM_IPSUM_RAW</span><span class="p">;</span>

            <span class="nd">#[bench]</span>
            <span class="k">fn</span> <span class="nf">encode_r1</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Bencher</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">b</span><span class="nf">.iter</span><span class="p">(||</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="k">mut</span> <span class="n">lorem_ipsum_encoded</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
                    <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="nv">$prefix</span><span class="p">(</span><span class="n">LOREM_IPSUM_RAW</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">lorem_ipsum_encoded</span><span class="p">);</span>
                <span class="p">});</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">gen_benches!</span><span class="p">(</span><span class="n">encode</span><span class="p">);</span>
<span class="nd">gen_benches!</span><span class="p">(</span><span class="n">encode_lookahead</span><span class="p">);</span>
</code></pre></div></div>

<p>This uses the first 4 paragraphs or so from <a href="https://lipsum.com/">Lorem Ipsum</a>, and on my machine the input buffering version is always faster:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> name       encode:: ns/iter  encode_lookahead:: ns/iter  diff ns/iter   diff %  speedup 
 encode_r1  4,243             3,745                               -498  -11.74%   x 1.13
</code></pre></div></div>

<h2 id="faster-decode">Faster decode</h2>

<p>Say we wanted to seriously speed up our decoding. We could do so by dropping the check of an unexpected zero. Why? Well if you drop that check, a zero marker will tell you exactly how many bytes you can copy over verbatim before the next marker. Which you can do in Rust with the <code class="highlighter-rouge">extend_from_slice</code> function, which is probably a bit faster than a manual loop. Let’s try that out:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">decode</span><span class="p">(</span><span class="n">encoded_data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">decoded_data_buffer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">encoded_data</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">start_length_out_buffer</span> <span class="o">=</span> <span class="n">decoded_data_buffer</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">zero_marker</span> <span class="o">=</span> <span class="n">encoded_data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">next_index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="n">zero_marker</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">zero_marker</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">decoded_data_buffer</span><span class="nf">.len</span><span class="p">()</span> <span class="err">-</span> <span class="n">start_length_out_buffer</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">next_index</span> <span class="o">&gt;=</span> <span class="n">encoded_data</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="n">decoded_data_buffer</span><span class="nf">.len</span><span class="p">()</span> <span class="err">-</span> <span class="n">start_length_out_buffer</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="n">decoded_data_buffer</span><span class="nf">.extend_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">encoded_data</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="o">..</span><span class="n">next_index</span><span class="p">]);</span>

        <span class="k">if</span> <span class="n">zero_marker</span> <span class="o">!=</span> <span class="nn">u8</span><span class="p">::</span><span class="nf">max_value</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">&amp;&amp;</span> <span class="n">encoded_data</span><span class="p">[</span><span class="n">next_index</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">decoded_data_buffer</span><span class="nf">.push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">zero_marker</span> <span class="o">=</span> <span class="n">encoded_data</span><span class="p">[</span><span class="n">next_index</span><span class="p">]</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">next_index</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We don’t use iterators any more in this code. This is not very idiomatic for Rust, since Rust can more easily eliminate bounds checks for loops over iterators. However, we do get the <code class="highlighter-rouge">extend_from_slice</code> which is hopefully more efficient. So what we do is keep the index into the data around, and look up the zero marker. If the zero marker is zero, we’re done, end of message. If the index is out of bounds, that’s an error. Otherwise we extend from the <code class="highlighter-rouge">index+1</code> up to (not including) the next index. The <code class="highlighter-rouge">+1</code> is because <code class="highlighter-rouge">index</code> always points to a zeromarker. Should the zero marker be <code class="highlighter-rouge">255</code> or the next zero marker be <code class="highlighter-rouge">0</code>, then we don’t need to add a zero after the copied data. Then we update the zero marker and index.</p>

<p>To test this we run another benchmark, this time decoding the encoded lorem ipsum text. The results are quite promising:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> name       naive_decode:: ns/iter  decode:: ns/iter  diff ns/iter   diff %  speedup 
 decode_r1  3,962                   361                     -3,601  -90.89%  x 10.98
</code></pre></div></div>

<p>Naturally, this faster decode <em>is</em> too permissive. So a quickcheck test such as the following will fail most of the time by finding an incorrect COBS encoded message with an unexpected zero.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nd">quickcheck!</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">naive_decode_eq_decode</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">b1</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">b2</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">r1</span> <span class="o">=</span> <span class="nf">decode</span><span class="p">(</span><span class="n">data</span><span class="nf">.as_slice</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">b1</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">r2</span> <span class="o">=</span> <span class="nf">naive_decode</span><span class="p">(</span><span class="n">data</span><span class="nf">.as_slice</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">b2</span><span class="p">);</span>
            <span class="k">if</span> <span class="k">let</span> <span class="p">(</span><span class="nf">Err</span><span class="p">(</span><span class="n">_</span><span class="p">),</span> <span class="nf">Err</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="o">=</span> <span class="p">(</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span><span class="p">)</span> <span class="p">{</span>
                <span class="kc">true</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">r1</span> <span class="o">==</span> <span class="n">r2</span> <span class="o">&amp;&amp;</span> <span class="n">b1</span> <span class="o">==</span> <span class="n">b2</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<h2 id="faster-encode">Faster encode</h2>

<p>Perhaps we can also improve our look-ahead encoding, by not explicitly buffering anything. If instead we just find the position of the next zero, we can use some index juggling:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">encode_itertools</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">encoded_data_buffer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">itertools</span><span class="p">::</span><span class="n">Itertools</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">start_length_out_buffer</span> <span class="o">=</span> <span class="n">encoded_data_buffer</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="n">_usize</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">z_index</span> <span class="n">in</span> <span class="n">data</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.chain</span><span class="p">(</span><span class="nn">iter</span><span class="p">::</span><span class="nf">once</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0</span><span class="p">))</span><span class="nf">.positions</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">b</span><span class="p">|</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">z_index</span> <span class="o">&gt;=</span> <span class="n">index</span><span class="p">);</span>
        <span class="c">// index is always still-unvisited, so when z_index == index, we need to write a 1</span>
        <span class="nd">macro_rules!</span> <span class="n">offset_between_zeroes</span> <span class="p">{</span> <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="n">z_index</span> - <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}}</span>
        <span class="k">while</span> <span class="nd">offset_between_zeroes!</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">MAX</span> <span class="p">{</span>
            <span class="n">encoded_data_buffer</span><span class="nf">.push</span><span class="p">(</span><span class="n">MAXu8</span><span class="p">);</span>
            <span class="n">encoded_data_buffer</span><span class="nf">.extend_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="o">..</span><span class="n">index</span> <span class="o">+</span> <span class="n">MAX_CONSECUTIVE</span><span class="p">]);</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="n">MAX_CONSECUTIVE</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">encoded_data_buffer</span><span class="nf">.push</span><span class="p">(</span><span class="nd">offset_between_zeroes!</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u8</span><span class="p">);</span>
        <span class="n">encoded_data_buffer</span><span class="nf">.extend_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="o">..</span><span class="n">z_index</span><span class="p">]);</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">z_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">encoded_data_buffer</span><span class="nf">.push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="n">encoded_data_buffer</span><span class="nf">.len</span><span class="p">()</span> <span class="err">-</span> <span class="n">start_length_out_buffer</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We use <a href="https://crates.io/crates/itertools">itertools</a> here for the <code class="highlighter-rouge">positions</code> iterator method. We go over the whole data looking for the indices of the zero bytes. We’ve encoded up to <code class="highlighter-rouge">index</code>, so if the offset between there and the zero is too far, we need to add the special zero markers and the <code class="highlighter-rouge">MAX_CONSECUTIVE</code> number of data bytes. In the end we always write the offset as zero marker, then the data up to the zero, then set the index to <em>after</em> the zero.</p>

<p>This is again a bit faster because we don’t copy each byte into a buffer only to copy the buffer again. The positions iterator method now does the look-ahead for us.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> name       encode_lookahead:: ns/iter  encode_itertools:: ns/iter  diff ns/iter   diff %  speedup 
 encode_r1  3,750                       2,756                               -994  -26.51%   x 1.36
</code></pre></div></div>

<h1 id="conclusion">Conclusion</h1>

<p>So we’ve seen some Rust code today that was hopefully readable to you. Tests are easy because they’re built-in. Property based tests are just a crate import away. Benchmarks require the nightly compiler, but only those do, so you can just use <code class="highlighter-rouge">cargo +nightly bench</code> to run them. The comparison tables are generated with <a href="https://crates.io/crates/cargo-benchcmp"><code class="highlighter-rouge">cargo-benchcmp</code></a>.</p>

<p>I’ve shown some of my implementations for COBS in Rust, but this was only a learning exercise. I hope this inspires you to find a project of your own to get more experience with Rust. A <em>real</em> implementation of COBS in Rust can be found in the <a href="https://crates.io/crates/cobs"><code class="highlighter-rouge">cobs</code></a> crate, which allows you to use whichever sentinel value you want, can decode in-place, and doesn’t even use vectors so you can use the crate without the standard library.</p>

<h1 id="footnotes">Footnotes</h1>

<div class="footnotes">
  <ol>
    <li id="fn:overhead">
      <p>If you count the zero at the end of a frame as part of the COBS algorithm, it has a minimum offset of 2. But apparently people usually count that as a separate “packetize” step, or so it says on Wikipedia. <a href="#fnref:overhead" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Whatever</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li><a href="mailto:jeff.smits@gmail.com">jeff.smits@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/Apanatshka">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">Apanatshka</span>
            </a>
          </li>
          

          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">A web log. Mostly about computer science-y stuff. 
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
