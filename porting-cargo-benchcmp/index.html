<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Porting cargo benchcmp | Whatever</title>
  <meta name="title" content="Porting cargo benchcmp">
<meta name="description" content="A web log. Mostly about computer science-y stuff." />

  <meta name="referrer" content="no-referrer-when-downgrade">
  <link rel="alternate" type="application/rss+xml" title="Whatever" href="https://blog.jeffsmits.net/rss.xml">
  <link rel="stylesheet" href="https://blog.jeffsmits.net/style.css">
  </head>
<body>
  <header>
  

  <a href="https://blog.jeffsmits.net/" class="title">
    <h1>Whatever</h1>
  </a>
  <nav>
    

  

  </nav>
</header>

    <h1>Porting cargo benchcmp</h1>
      <p>
        <i>
          <time datetime='2016-09-04T00:00:00+00:00' pubdate>04 Sep, 2016</time>
        </i>
      </p>
  <main>
    <p><strong>TL;DR:</strong> I’ve ported the tool <a href="https://crates.io/crates/cargo-benchcmp"><code>cargo-benchcmp</code></a> from <a href="https://github.com/BurntSushi/cargo-benchcmp/blob/1d23dec5dd3abe3939cfea030162a7dc6461e544/cargo-benchcmp">Python</a> to <a href="https://github.com/BurntSushi/cargo-benchcmp">Rust</a> and added some functionality. There is more to come which is mostly waiting for review in <a href="https://github.com/BurntSushi/cargo-benchcmp/pulls">pull requests</a>.</p>
<p>I’ve been messing around with Rust for a while now, and I found a little utility called <a href="https://github.com/BurntSushi/cargo-benchcmp"><code>cargo-benchcmp</code></a> by the famous <a href="http://blog.burntsushi.net/about/">BurntSushi (Andrew Gallant)</a>. You may have seen the benchmark comparisons in one of his <a href="http://blog.burntsushi.net/transducers/">blogposts</a> already. I found out that the utility was a nice <a href="https://github.com/BurntSushi/cargo-benchcmp/blob/1d23dec5dd3abe3939cfea030162a7dc6461e544/cargo-benchcmp">single file Python script</a>. Not a quick and dirty hack, but classes and a few docstrings. I was already messing around with some of my own rust code where I wanted to do a comparison between benchmarks, so that’s great. But the tool only worked with comparison of the same tests over time, and I wanted a comparison of the same tests on multiple implementations. So what do you do? Well, it’s a small open source tool so I decided to contribute. That’s what this post is about.</p>
<h1 id="porting-the-tool">Porting the tool</h1>
<p>I’m teaching myself Rust by writing in it, and my Python is a little rusty (heh), so I decided the first thing I’d do was port the tool to Rust. So I set out to find a good crate for handling command line arguments. And I found an implementation for <a href="http://docopt.org/">docopt</a>, which seems like a rather nice initiative. I can recommend the <a href="https://github.com/docopt/docopt.rs">Rust implementation of doctopt</a> because it goes further than the basic API, and uses <code>rustc-serialize</code> and macros to get you a nice struct with all the command-line arguments with mostly the right types already.</p>
<p>I also grabbed the <a href="https://crates.io/crates/regex"><code>regex</code></a> crate of course, to take the benchmark results apart. The regex for a line is the benchmark was something I could just copy, but I decided to pick it apart and <a href="https://github.com/BurntSushi/cargo-benchcmp/blob/0512f17d1206f919706e1486e3dca4dd99068a39/src/benchmark.rs#L114-L119">add comments</a>. The rest of the code started out in mostly the same structure as the Python code, with structs and functions instead of classes.</p>
<p>Now for the output I wanted a nice table format and I found another crate for that which is very simple. It’s called <a href="https://crates.io/crates/tabwriter"><code>tabwriter</code></a> and it’s a port of the Go package for elastic tabstops. Which makes creating a table as simple as putting a <code>\t</code> (tab) character between you’re columns. Given that that’s what the character was originally intended for, it’s a rather elegant solution.</p>
<p>Grabbing all of these crates with <code>cargo</code> is very simple, and one of the pleasures of the Rust ecosystem. To make it even easier I did <code>cargo install cargo-edit</code>, which gives you three extra cargo subcommands: <code>list</code>, <code>add</code> and <code>rm</code>. So I could just <code>cargo add tabwriter</code> to get the latest version of the crate added to project dependencies. No more manual editing of <code>Cargo.toml</code>!</p>
<p>Another thing I learnt along the way was that cargo will just dispatch subcommands to whatever available <code>cargo-subcommand</code> executable on your <code>PATH</code>. So I didn’t have to do anything special to make this Rust port available to Rust users. You can right now do <code>cargo install cargo-benchcmp</code>, and have <code>cargo benchcmp</code> just work.</p>
<p>Something funny to note about the dependencies I’ve mentioned so far – <code>docopt</code>, <code>regex</code> and <code>tabwriter</code> – they’re all written by BurntSushi. I couldn’t have done this Rust port of his tool so easily without his other crates.</p>
<h1 id="comparing-modules">Comparing modules</h1>
<p>In the project where I had benchmarks to compare, I generated different modules with the names of their implementation technique, all with the same benchmarks. This is fairly easy to <a href="https://github.com/Apanatshka/dnfa/blob/5cdb4307a06aee51f2d19f2619e0ff2e5e49af18/benches/basic.rs">set up with a macro</a>. The result is the same benchmark name, with different prefixes for the different implementations. So in the port of <code>benchcmp</code>, I added an option to provide two module names first, and the one or more files to read. The files would still contain the benchmark results, but the module names would be used to pick the benchmarks to compare.</p>
<h1 id="the-current-interface">The current interface</h1>
<p>Help message:</p>
<pre data-lang="sh" style="background-color:#0f1419;color:#bfbab0;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#ffb454;">$</span><span> cargo benchcmp</span><span style="color:#f29718;"> --help
</span><span style="color:#ffb454;">Compares</span><span> Rust micro-benchmark results.
</span><span>
</span><span style="color:#ffb454;">Usage:
</span><span>    </span><span style="color:#ffb454;">cargo</span><span> benchcmp </span><span style="color:#ff7733;">[</span><span>options</span><span style="color:#ff7733;">] </span><span style="color:#f29668;">&lt;</span><span>old</span><span style="color:#f29668;">&gt; &lt;</span><span>new</span><span style="color:#f29668;">&gt;
</span><span>    </span><span style="color:#ffb454;">cargo</span><span> benchcmp </span><span style="color:#ff7733;">[</span><span>options</span><span style="color:#ff7733;">] </span><span style="color:#f29668;">&lt;</span><span>old</span><span style="color:#f29668;">&gt; &lt;</span><span>new</span><span style="color:#f29668;">&gt; &lt;</span><span>file</span><span style="color:#f29668;">&gt;
</span><span>    </span><span style="color:#ffb454;">cargo</span><span> benchcmp</span><span style="color:#f29718;"> -h </span><span style="color:#f29668;">| </span><span style="color:#ffb454;">--help
</span><span>    </span><span style="color:#ffb454;">cargo</span><span> benchcmp</span><span style="color:#f29718;"> --version
</span><span>
</span><span style="color:#ffb454;">The</span><span> first version takes two files and compares the common benchmarks.
</span><span>
</span><span style="color:#ffb454;">The</span><span> second version takes two benchmark name prefixes and one benchmark output
</span><span style="color:#ffb454;">file,</span><span> and compares the common benchmarks (as determined by comparing the
</span><span style="color:#ffb454;">benchmark</span><span> names with their prefixes stripped)</span><span style="color:#f07178;">.</span><span> Benchmarks not matching either
</span><span style="color:#ffb454;">prefix</span><span> are ignored completely.
</span><span>
</span><span style="color:#ffb454;">If</span><span> benchmark output is sent on stdin, then the second version is used and the
</span><span style="color:#ffb454;">third</span><span> file parameter is not needed.
</span><span>
</span><span style="color:#ffb454;">Options:
</span><span>    </span><span style="color:#ffb454;">-h,</span><span style="color:#f29718;"> --help</span><span>           Show this help message and exit.
</span><span>    </span><span style="color:#ffb454;">--version</span><span>            Show the version.
</span><span>    </span><span style="color:#ffb454;">--threshold </span><span style="color:#f29668;">&lt;</span><span>n</span><span style="color:#f29668;">&gt;</span><span>      Show only comparisons with a percentage change greater
</span><span>                         </span><span style="color:#ffb454;">than</span><span> this threshold.
</span><span>    </span><span style="color:#ffb454;">--variance</span><span>           Show the variance of each benchmark.
</span><span>    </span><span style="color:#ffb454;">--improvements</span><span>       Show only improvements.
</span><span>    </span><span style="color:#ffb454;">--regressions</span><span>        Show only regressions.
</span></code></pre>
<p>An example output:</p>
<pre data-lang="sh" style="background-color:#0f1419;color:#bfbab0;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#ffb454;">$</span><span> cd aho-corasick
</span><span style="color:#ffb454;">$</span><span> cargo bench </span><span style="color:#f29668;">| </span><span style="color:#ffb454;">cargo</span><span> benchcmp</span><span style="color:#f29718;"> --variance --threshold</span><span> 5 dense:: dense_boxed:: -
</span><span> </span><span style="color:#ffb454;">name</span><span>                                dense:: ns/iter               dense_boxed:: ns/iter         diff ns/iter  diff % 
</span><span> </span><span style="color:#ffb454;">ac_one_prefix_byte_every_match</span><span>      112,957 (+/- 1480) (</span><span style="color:#ffb454;">88</span><span> MB/s)  150,581 (+/- 814) (</span><span style="color:#ffb454;">66</span><span> MB/s)         37,624  33.31% 
</span><span> </span><span style="color:#ffb454;">ac_one_prefix_byte_random</span><span>           16,096 (+/- 292) (</span><span style="color:#ffb454;">621</span><span> MB/s)   20,273 (+/- 60) (</span><span style="color:#ffb454;">493</span><span> MB/s)           4,177  25.95% 
</span><span> </span><span style="color:#ffb454;">ac_ten_bytes</span><span>                        58,588 (+/- 218) (</span><span style="color:#ffb454;">170</span><span> MB/s)   108,092 (+/- 683) (</span><span style="color:#ffb454;">92</span><span> MB/s)         49,504  84.50% 
</span><span> </span><span style="color:#ffb454;">ac_ten_diff_prefix</span><span>                  58,601 (+/- 215) (</span><span style="color:#ffb454;">170</span><span> MB/s)   108,082 (+/- 712) (</span><span style="color:#ffb454;">92</span><span> MB/s)         49,481  84.44% 
</span><span> </span><span style="color:#ffb454;">ac_ten_one_prefix_byte_every_match</span><span>  112,920 (+/- 1454) (</span><span style="color:#ffb454;">88</span><span> MB/s)  150,561 (+/- 824) (</span><span style="color:#ffb454;">66</span><span> MB/s)         37,641  33.33% 
</span><span> </span><span style="color:#ffb454;">ac_ten_one_prefix_byte_random</span><span>       19,181 (+/- 251) (</span><span style="color:#ffb454;">521</span><span> MB/s)   23,684 (+/- 427) (</span><span style="color:#ffb454;">422</span><span> MB/s)          4,503  23.48% 
</span><span> </span><span style="color:#ffb454;">ac_two_one_prefix_byte_every_match</span><span>  112,934 (+/- 2037) (</span><span style="color:#ffb454;">88</span><span> MB/s)  150,571 (+/- 1618) (</span><span style="color:#ffb454;">66</span><span> MB/s)        37,637  33.33% 
</span><span> </span><span style="color:#ffb454;">ac_two_one_prefix_byte_random</span><span>       16,511 (+/- 142) (</span><span style="color:#ffb454;">605</span><span> MB/s)   21,009 (+/- 94) (</span><span style="color:#ffb454;">476</span><span> MB/s)           4,498  27.24% 
</span></code></pre>
<h1 id="things-to-come">Things to come</h1>
<p>I’m not done with this tool just yet. I did open a PR to the original repo and got a great code review from BurntSushi. He published it to <a href="https://crates.io/">crates.io</a> too, and beat me to the punch by posting on Reddit, but I hope this post was still interesting to you. Here’s some things I’ve been working on:</p>
<h2 id="coloured-output">Coloured output</h2>
<p>Already during the first code review I figured out that my Rust port didn’t get the output quite right. The table was already left-justified, whereas the original tool did right-justification of the last two columns. I liked the original output better so I switched <code>tabwriter</code> for <a href="https://crates.io/crates/prettytable-rs"><code>prettytable-rs</code></a>, which is a nice ascii table generator. Out of the box it generated a lot of rules as well, but the format can be customised and one without any rules is even available as a preset <code>prettytable::format::consts::FORMAT_CLEAN</code>. The macros for the rows are well done, though I might have stumbled upon a regression where you <em>have</em> to give each cell the default format <code>d-&gt;"you cell here"</code> to get it to work.</p>
<p>Anyway, that happened, I added right-justification. But the crate also gives the option to add colours to your table. So a simple change to the code, and now <code>benchcmp</code> will give you red rows for regressions and green rows for improvements (<a href="https://github.com/BurntSushi/cargo-benchcmp/pull/9">Pull Request</a>). In my experience, this makes the options show only one or the other obsolete, but it doesn’t hurt so it’s still in there.</p>
<pre data-lang="sh" style="background-color:#0f1419;color:#bfbab0;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#ffb454;">$</span><span> cd aho-corasick
</span><span style="color:#ffb454;">$</span><span> cargo bench </span><span style="color:#f29668;">| </span><span style="color:#ffb454;">cargo</span><span> benchcmp</span><span style="color:#f29718;"> --variance</span><span> dense:: dense_boxed:: -
</span></code></pre>
<p><img src="https://blog.jeffsmits.net/porting-cargo-benchcmp/screenshot_coloured_output.png" alt="Coloured output of the tool, with a bold header line, a lot of green (improvement) lines and two read (regression) lines" /></p>
<h2 id="n-way-comparison-plotting">N-way comparison: Plotting</h2>
<p>Warning: This feature may not actually make it into the tool proper. You can find <a href="https://github.com/BurntSushi/cargo-benchcmp/issues/8">the discussion around that on github</a>. For now this functionality lives in a <a href="https://github.com/Apanatshka/cargo-benchcmp/tree/plot">branch</a>.</p>
<p>Comparing two implementations or commits at a time is great for day-to-day use and the table gives you detailed information. But when you just implemented a feature in a few different ways and found another crate that gives the same functionality, you really need an overview of how all of these things compare to each other. So I added a new subcommand <code>plot</code> to <code>benchcmp</code> (and moving the table functionality to subcommand <code>table</code>; I apologise in advance for the breaking change).</p>
<p>The plot command compares by file or by module, any benchmark test that is present in multiple files/modules. It generated images in <code>target/benchcmp</code>, one file per benchmark, with a barchart/histogram plot + error bars for the variance. To generate the plots it uses <code>gnuplot</code>, which should be installed separately and put on your <code>PATH</code>. I suppose that’s a weakness, but it was the easiest way to do this. Any suggestions to cut or simplify that dependency would be much appreciated, but I couldn’t find a pure Rust plotting crate. If you’re wondering, I don’t use the <a href="https://crates.io/crates/gnuplot"><code>gnuplot</code> crate</a>, though I did try it at first. In the end it was easier to generate a gnuplot script myself than work with the limited subset of the crate, which does shallow bindings anyway. On the upside, I got to learn about gnuplot, which is a very handy (and powerful) tool indeed!</p>
<p><img src="https://cloud.githubusercontent.com/assets/1237863/17133147/362f7c22-5325-11e6-909a-bf76a8ecc85a.png" alt="A bar plot with whiskers that compares benchmark test ac_ten_one_prefix_byte_every_match for all implementations of aho-corasick (dense, dense_boxed, full, full_overlap and sparse)" /></p>
<h2 id="tests">Tests</h2>
<p>One of the things that came up after the first release of the Rust version of <code>cargo-benchcmp</code> is tests. I kind of didn’t write any… So I <a href="https://github.com/BurntSushi/cargo-benchcmp/issues/3">asked</a> for a little advice on what to test, and got to work. So now I can report that <code>cargo-benchcmp</code> is pretty well-tested with <a href="https://github.com/BurntSushi/quickcheck"><code>quickcheck</code></a> for all the unit tests and <a href="https://github.com/nathanross/second_law"><code>second_law</code></a> for the integration tests (<a href="https://github.com/BurntSushi/cargo-benchcmp/pull/10">Pull Request</a>). So if you need practical examples of quickcheck properties, implementing your own <code>Arbitrary</code> instances, or integration testing a Rust commandline tool, or if you’re just curious, have a look :)</p>
<h2 id="better-statistics">Better statistics</h2>
<p>There is <a href="https://github.com/BurntSushi/cargo-benchcmp/issues/4">one last issue</a> on the repo for using better statistics when comparing benchmark measurements. I haven’t looked into this one yet. We may need more information than <code>cargo bench</code> currently provides. Feel free you look into this one yourself dear reader. Just remember to outline your plan in the issue before you start doing major work. I made the mistake not to do that with the plotting feature, and now that work might not survive… But at least it got me a bit more to write about here ^^</p>
<h2 id="real-world-comparisons-with-the-tool">Real world comparisons with the tool</h2>
<p>This post uses only small examples of <code>cargo benchcmp</code> output. I want to write a longer post on the implementation of finite automata with benchmark comparisons, along with performance traces and optimisations. But that may take some more time because I’m still figuring out how to use <code>perf</code> and <code>callgrind</code> etc., and my implementation is still squarely beaten by BurntSushi’s <a href="https://github.com/burntsushi/aho-corasick"><code>aho-corasick</code></a> crate. But, you know, whatever ¯\_(ツ)_/¯</p>

  </main>
  <p>
        Tags:
          <a href="https://blog.jeffsmits.net/tags/rust/">#rust</a>
          <a href="https://blog.jeffsmits.net/tags/tool/">#tool</a>
          <a href="https://blog.jeffsmits.net/tags/benchmark/">#benchmark</a>
  </p>
<footer>
    Made with <a href="https://codeberg.org/alanpearce/zola-bearblog">Zola ʕ•ᴥ•ʔ Bear</a>
</footer>
</body>
</html>
