<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LL Parsing and Recursive Descent | Whatever</title>
  <meta name="title" content="LL Parsing and Recursive Descent">
<meta name="description" content="A web log. Mostly about computer science-y stuff." />

  <meta name="referrer" content="no-referrer-when-downgrade">
  <link rel="alternate" type="application/rss+xml" title="Whatever" href="https://blog.jeffsmits.net/rss.xml">
  <link rel="stylesheet" href="https://blog.jeffsmits.net/style.css">
  </head>
<body>
  <header>
  

  <a href="https://blog.jeffsmits.net/" class="title">
    <h1>Whatever</h1>
  </a>
  <nav>
    

  

  </nav>
</header>

    <h1>LL Parsing and Recursive Descent</h1>
      <p>
        <i>
          <time datetime='2024-04-07T00:00:00+00:00' pubdate>07 Apr, 2024</time>
        </i>
      </p>
  <main>
    <p>Hello again! I’m picking up my <a href="https://blog.jeffsmits.net/theory-of-computation/">series on Automata</a>, with this post that goes into what I had always meant to get to: parsers. We’ll check out the old-school linear time parsing algorithms, which only need to go over the input once, without backtracking or caching. Originally this was one big post, but given the feedback I’ve gotten from (non-)readers, I’ve now split it up into two. In this first post we’ll check out LL, parse tables, and recursive descent. This post is meant to be readable for people unfamiliar with parsing, and yet be interesting for those who are familiar with the more traditional explanations! It’s still interesting because I like to explain things from an automata point of view instead of a procedural algorithm. I’ll use examples of grammars, and tables, and automata, and even some Rust code to show you how to implement a parser. The <a href="https://blog.jeffsmits.net/lr-parsing-recursive-ascent/">second post</a> is on LR parsing. Enjoy!</p>
<h1 id="refresher-from-pushy-automata">Refresher from Pushy Automata</h1>
<p>We’ll start with a brief refresher from the previous post of the series, <a href="https://blog.jeffsmits.net/pushy-automata/">pushy automata</a>, since that was a little while back.</p>
<h2 id="push-down-automata">Push-Down Automata</h2>
<p>Push-down automata (PDAs) are automata with a <em>stack</em>. Normal finite automata just consume input and have fixed memory via their states. PDAs can remember things on a single stack too, by pushing onto it and popping from it. Here’s a deterministic PDA for recognising the language of words that start with zeroes, followed by an equal number of ones:</p>


<img src="https://blog.jeffsmits.net/graphviz/non-regular-deterministic.d05812ca2e175a1d.svg" alt="Non-regular language example, deterministic">
<p>So we start at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><msub><mi>q</mi><mn>0</mn></msub></math>, see if there is a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mn>0</mn></math> as input, ignore the top of the stack, and put a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi mathvariant="normal">$</mi></math> on the stack as a marker for the end of the stack. Now we’re in state <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><msub><mi>q</mi><mn>1</mn></msub></math>, in which we can consume more zeroes from the input and put those on the stack. If we find a one as input, we remove a zero from the stack by not pushing anything new on the stack. Now we’re in state <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><msub><mi>q</mi><mn>2</mn></msub></math> where we remove zeroes from the stack for every one in the input, until we consume the final one by removing the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi mathvariant="normal">$</mi></math> from the stack.</p>
<blockquote>
<p>Aside: This is one of the examples from the old blog post, and I now see that it is missing a transition! This automaton rejects the input <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mn>01</mn></math>, because there is no transition <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><msub><mi>q</mi><mn>1</mn></msub><mo>→</mo><msub><mi>q</mi><mn>3</mn></msub></math> labeled <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mn>1</mn><mo>,</mo><mi mathvariant="normal">$</mi><mo>→</mo><mi>ε</mi></math>. Oops ^_^</p>
</blockquote>
<h2 id="context-free-grammars-derivations-and-a-naive-pda-translation">Context-Free Grammars, Derivations, and a naive PDA translation</h2>
<p>A context-free grammar that describes the above language is:</p>
<table><thead><tr><th style="text-align: left"></th><th style="text-align: left"></th></tr></thead><tbody>
<tr><td style="text-align: left"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>S</mi><mo>=</mo><mn>0</mn><mi>S</mi><mn>1</mn></math></td><td style="text-align: left">(step)</td></tr>
<tr><td style="text-align: left"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>S</mi><mo>=</mo><mi>ε</mi></math></td><td style="text-align: left">(<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>ε</mi></math>)</td></tr>
</tbody></table>
<p>Sort <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>S</mi></math> is the start symbol, the starting point in the grammar. If we’re using the grammar <em>productively</em> we start from the start symbol and use the rules left-to-right to replace sorts until we get the sentence in the corresponding context-free language that we want. Something like: $ S \to 0 S 1 \to 0 0 S 1 1 \to 0 0 1 1 $. This is called a <em>derivation</em>.</p>
<p>The most general, naive way to derive a push-down automaton for any context-free grammar is by pushing the end-of-stack and start symbol at the start, having a “main” state that uses the grammar rules with the body reversed (to deal with the stack order), and an accept state that pops the end-of-stack:</p>


<img src="https://blog.jeffsmits.net/graphviz/binary-grammar.ea4303ed8632e2ff.svg" alt="Naive PDA of the above binary grammar">
<p>Here the stack grows left-to-right, so the lowest symbol on the stack is $ (end of stack), followed by S (the grammar start symbol). By the rules of the grammar we can manipulate the top of the stack and rewrite it to the body. If the input lines up with what we have on the stack, we can eliminate both. It’s simple, but inefficient because of all the nondeterminism.</p>
<h2 id="derivations-parse-trees-and-ambiguity">Derivations, Parse Trees and Ambiguity</h2>
<p>Let’s look at a slightly more interesting grammar from a parser perspective:</p>
<table><thead><tr><th style="text-align: left"></th><th style="text-align: left"></th></tr></thead><tbody>
<tr><td style="text-align: left"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>S</mi><mo>=</mo><mi>S</mi><mo>+</mo><mi>S</mi></math></td><td style="text-align: left">(add)</td></tr>
<tr><td style="text-align: left"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>S</mi><mo>=</mo><mi>S</mi><mo>*</mo><mi>S</mi></math></td><td style="text-align: left">(mul)</td></tr>
<tr><td style="text-align: left"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>S</mi><mo>=</mo><mn>1</mn></math></td><td style="text-align: left">(<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>ε</mi></math>)</td></tr>
</tbody></table>
<p>When you want to derive <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mn>1</mn><mo>+</mo><mn>1</mn><mo>*</mo><mn>1</mn></math> , you can do this in all manner of ways. The following derivation picks just an arbitrary sort on which to apply a rule from the grammar:</p>
<ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>S</mi></math>  (first S)</li>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>S</mi><mo>+</mo><mi>S</mi></math>  (first S)</li>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mn>1</mn><mo>+</mo><mi>S</mi></math>  (first S)</li>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mn>1</mn><mo>+</mo><mi>S</mi><mo>*</mo><mi>S</mi></math>  (second S)</li>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mn>1</mn><mo>+</mo><mi>S</mi><mo>*</mo><mn>1</mn></math>  (first S)</li>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mn>1</mn><mo>+</mo><mn>1</mn><mo>*</mo><mn>1</mn></math></li>
</ol>
<p>Notice how in some steps the leftmost <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>S</mi></math> was replaced, while in others the rightmost was replaced. Generally speaking, you’ll want either a leftmost or a rightmost derivation for parsers, which is to say: a grammar rule is always applied to the leftmost or rightmost sort. There are three reasons for this. The first is that you want a parser to be predictable in when it applies grammar rules, as you may connect so-called <em>semantic actions</em> to each rule. These are pieces of code that are run when the parser applies the particular rule. (A typical example is a simple calculator). Such actions could perform side-effects, therefore order matters. For this reason, leftmost vs rightmost can also be observed. Two other reasons you to want this predictable derivation order is ease of implementation, and ease of proving things about your algorithm. These last two care less for whether it’s leftmost or rightmost.</p>
<p>The most common semantic actions I’m aware of is to build a syntax tree with a parser. This builds a tree structure out of the parsed text. A parse tree, or concrete syntax tree, contains all the rule applications as seen in the grammar. An abstract syntax tree abstracts over some parts of the syntax tree, such as leaving out whitespace, or parentheticals (the shape of the tree captures the precedence anyway), or injections (grammars rules of the form <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><msub><mi>S</mi><mn>1</mn></msub><mo>=</mo><msub><mi>S</mi><mn>2</mn></msub></math> ). Let’s look at some parse trees of the last example, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mn>1</mn><mo>+</mo><mn>1</mn><mo>*</mo><mn>1</mn></math> :</p>


<img src="https://blog.jeffsmits.net/graphviz/parse-trees.d6bd2504748a4c7d.svg" alt="Parse trees of 1 + (1 * 1) and (1 + 1) * 1">
<p>Notice how the leaves of the two trees are in the same order left-to-right as the input, but for the left tree the plus is higher up in the tree while in the right tree the star is higher up. If we want to interpreter the input as simple arithmetic, where multiplication binds tighter than addition, the left tree is the one we want. This is the predecedence of the operators, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mo>*</mo><mo>></mo><mo>+</mo></math> .</p>
<p>When you can get multiple trees like this, the grammar is called ambiguous. More formally, if you use only leftmost derivations (or only rightmost) and still find two distinct derivations that give the same sentence, the grammar is ambiguous. So to be clear: the above trees can be created with only leftmost derivations, it’s not a matter of choosing one or the other for the two trees. Derivation order (leftmost or rightmost) has to do with <em>side-effect order</em> of semantic actions only. When you build trees you don’t really need side-effects, so the derivation order has no effect on it.</p>
<p><strong>With that recap out of the way:</strong> For the purposes of <em>this</em> blog post, we’ll look at <em>un</em>ambiguous grammars for the languages we want to parse. Still, whether you use leftmost derivation or rightmost derivation in a parser that parses unambiguous grammars matters quite a lot in terms of what languages you can describe deterministically. It also influences how easily you can write a parser by hand for such a grammar, and how easily you can (programmatically) explain why your parser <em>doesn’t</em> accept certain inputs (parser error messages). So let’s have a look at LL and LR parsing techniques, where the first L in those abbreviations stands for Left-to-right (as in reading direction in text), and the second letters are respectively leftmost and rightmost derivation.</p>
<h1 id="topdown-strong-ll-parsing">Topdown, (Strong) LL parsing</h1>
<p>To take a good look at LL parsing, we will first work with a grammar that is not ambiguous or left-recursive:</p>
<table><thead><tr><th style="text-align: left"></th><th style="text-align: left"></th></tr></thead><tbody>
<tr><td style="text-align: left"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>S</mi><mo>=</mo><mi>F</mi></math></td><td style="text-align: left">(1)</td></tr>
<tr><td style="text-align: left"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>S</mi><mo>=</mo><mo>(</mo><mi>S</mi><mo>+</mo><mi>F</mi><mo>)</mo></math></td><td style="text-align: left">(2)</td></tr>
<tr><td style="text-align: left"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>F</mi><mo>=</mo><mi>a</mi></math></td><td style="text-align: left">(3)</td></tr>
</tbody></table>
<p>So sort <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>S</mi></math>  is the start symbol, we also have sort <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>F</mi></math> , and we have round brackets, plusses, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>a</mi></math> ’s. This is enough information to create a table that, based on (1) the next sort to be parsed and (2) the next symbol in the input, predicts which rule from the grammar to use to parse the input further. In other words, if you know where you are in the input and grammar, you can look ahead at the next symbol of input and tell which <em>unique</em> grammar rule predicts the next bit of input (assuming the input fits the grammar). The table for the above grammar looks like so:</p>
<div class="parsetable">
<table><thead><tr><th style="text-align: left"></th><th style="text-align: right"><code>(</code></th><th style="text-align: right"><code>a</code></th></tr></thead><tbody>
<tr><td style="text-align: left"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>S</mi></math></td><td style="text-align: right">2</td><td style="text-align: right">1</td></tr>
<tr><td style="text-align: left"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>F</mi></math></td><td style="text-align: right"></td><td style="text-align: right">3</td></tr>
</tbody></table>
</div>
<p>A table like the above is an LL(1) parse table, because it uses only 1 symbol of “look-ahead” in the columns. LL(1) grammars are always strong LL grammars, which means that they only need the combination of the sort to be parsed and the next symbol(s) to decide on a unique grammar rule to apply. In general, LL(k) grammars do not have to be strong, and if they are not, you also need to know what was already parsed from the input (the “left context”) in order to choose a unique grammar rule<sup class="footnote-reference" id="fr-LLdef-1"><a href="#fn-LLdef">[1]</a></sup>. For example, the following grammar is LL(2), and not strong:</p>
<table><thead><tr><th style="text-align: left"></th><th style="text-align: left"></th></tr></thead><tbody>
<tr><td style="text-align: left"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>S</mi><mo>=</mo><mi>A</mi><mspace width="1em"/><mi>a</mi><mspace width="1em"/><mi>b</mi><mspace width="1em"/><mi>A</mi><mspace width="1em"/><mi>b</mi><mspace width="1em"/><mi>a</mi></math></td><td style="text-align: left">(1)</td></tr>
<tr><td style="text-align: left"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>A</mi><mo>=</mo><mi>a</mi></math></td><td style="text-align: left">(2)</td></tr>
<tr><td style="text-align: left"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>A</mi><mo>=</mo></math></td><td style="text-align: left">(3)</td></tr>
</tbody></table>
<p>You can see this if you try to write an LL(2) parse table for it:</p>
<div class="parsetable">
<table><thead><tr><th style="text-align: left"></th><th style="text-align: right"><code>a a</code></th><th style="text-align: right"><code>a b</code></th><th style="text-align: right"><code>b a</code></th></tr></thead><tbody>
<tr><td style="text-align: left"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>S</mi></math></td><td style="text-align: right">1</td><td style="text-align: right">1</td><td style="text-align: right"></td></tr>
<tr><td style="text-align: left"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>A</mi></math></td><td style="text-align: right">2</td><td style="text-align: right">2,3</td><td style="text-align: right">3</td></tr>
</tbody></table>
</div>
<p>If you look ahead to <code>a b</code> on the input, and the next sort is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>A</mi></math>, then it really depends on whether you are at the start of the input or in the middle of rule 1. If you’re at the start, you must choose rule 3 so you can parse <code>a b</code> as part of the rule 1, but if you’re already in the middle of rule 1, you must choose rule 2 for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>A</mi></math> so you can continue to parse <code>b a</code> of rule 1.</p>
<p>If you mark <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>A</mi></math> in rule 1 with where you are in rule 1 ($ S = A₁\ a\ b\ A₂\ b\ a $), you get an LL(2) grammar that is strong, although the table for it is larger<sup class="footnote-reference" id="fr-table-1"><a href="#fn-table">[2]</a></sup>:</p>
<div class="parsetable">
<table><thead><tr><th style="text-align: left"></th><th style="text-align: right"><code>a a</code></th><th style="text-align: right"><code>a b</code></th><th style="text-align: right"><code>b a</code></th></tr></thead><tbody>
<tr><td style="text-align: left"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>S</mi></math></td><td style="text-align: right">1</td><td style="text-align: right">1</td><td style="text-align: right"></td></tr>
<tr><td style="text-align: left"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><msub><mi>A</mi><mn>1</mn></msub></math></td><td style="text-align: right">2</td><td style="text-align: right">3</td><td style="text-align: right"></td></tr>
<tr><td style="text-align: left"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><msub><mi>A</mi><mn>2</mn></msub></math></td><td style="text-align: right"></td><td style="text-align: right">2</td><td style="text-align: right">3</td></tr>
</tbody></table>
</div>
<p>In general, you can always use this trick to construct a strong, <em>structurally equivalent</em> LL grammar with the same look-ahead. This is quite useful for constructing simple LL parsers. However, the downside of these parsers is that on wrong input they can fail later than a more complicated LL(k) parser that works for the non-strong grammar. And that matters if you want to give nice error messages.</p>
<h3 id="an-intuition-for-table-construction-by-automaton">An intuition for table construction by automaton</h3>
<p>Building the above tables was a matter of keeping in mind what they mean, and squinting a little. But in the case of a larger grammar, or a parsetable generator, of course you want an exact process. Before I dive into <em>First</em> and <em>Follow</em> sets that are the traditional method for building these tables, let me give you a method that is less practical but in my opinion more intuitive.</p>
<p>Step 1: Let’s build a simple automaton for each rule of the grammar, where we assume both sorts and terminals are on the input.</p>


<img src="https://blog.jeffsmits.net/graphviz/ll-rule-automata.be659b2664c7a3cd.svg" alt="Simple automata for each grammar rule from the last example">
<p>Note how each node of a rule automaton has the number of the rule followed by the offset into the body of the rule. The state represents where we are in the rule while parsing by that rule. The last node doesn’t have this offset so you can easily identify it, even when it’s no longer a final state.</p>
<p>Typically you’ll find texts on parsers display the position in a rule more visually with “LR item” notation. This uses the actual rule and a dot to indicate where we are in the rule. While this makes individual automata states more readable, it makes the automata large and therefore harder to display in a readable way as a whole. That’s why you won’t find that notation in this post’s automata. But just to illustrate an example of the notation:</p>
<div class="parsetable">
<table><thead><tr><th style="text-align: left">Shorthand in this blog</th><th style="text-align: left">LR Item notation</th></tr></thead><tbody>
<tr><td style="text-align: left">S₁₀</td><td style="text-align: left"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>S</mi><mo>=</mo><mo>.</mo><mspace width="1em"/><mi>A</mi><mspace width="1em"/><mi>a</mi><mspace width="1em"/><mi>b</mi><mspace width="1em"/><mi>A</mi><mspace width="1em"/><mi>b</mi><mspace width="1em"/><mi>a</mi></math></td></tr>
<tr><td style="text-align: left">S₁₁</td><td style="text-align: left"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>S</mi><mo>=</mo><mi>A</mi><mspace width="1em"/><mo>.</mo><mspace width="1em"/><mi>a</mi><mspace width="1em"/><mi>b</mi><mspace width="1em"/><mi>A</mi><mspace width="1em"/><mi>b</mi><mspace width="1em"/><mi>a</mi></math></td></tr>
<tr><td style="text-align: left">S₁₅</td><td style="text-align: left"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>S</mi><mo>=</mo><mi>A</mi><mspace width="1em"/><mi>a</mi><mspace width="1em"/><mi>b</mi><mspace width="1em"/><mi>A</mi><mspace width="1em"/><mi>b</mi><mspace width="1em"/><mo>.</mo><mspace width="1em"/><mi>a</mi></math></td></tr>
<tr><td style="text-align: left">S₁</td><td style="text-align: left"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>S</mi><mo>=</mo><mi>A</mi><mspace width="1em"/><mi>a</mi><mspace width="1em"/><mi>b</mi><mspace width="1em"/><mi>A</mi><mspace width="1em"/><mi>b</mi><mspace width="1em"/><mi>a</mi><mspace width="1em"/><mo>.</mo></math></td></tr>
</tbody></table>
</div>
<p>Step 2: Now instead of consuming a sort with an automaton, we’ll use <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>ε</mi></math> rules to jump to the automata of the rules for that sort instead. We’ll use the PDA stack with unique labels to get back to where you would be after consuming the sort.</p>


<img src="https://blog.jeffsmits.net/graphviz/ll-single-automaton.799f4fb2d9457d92.svg" alt="Single PDA using the automata from the grammar rules">
<p>The <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mo>↓</mo><mrow></mrow><mi>X</mi></math> is an abbreviation for an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>ε</mi><mo>,</mo><mi>ε</mi><mo>→</mo><mi>X</mi></math> edge that pushes a symbol on the stack unconditionally, it was hard to get graphviz to cooperate on node placement of this graph otherwise… Now at every node that had a sort transition you have multiple transition options, these are where you need to look ahead. Soooo…</p>
<p>Step 3: at a sort transition node, for each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mo>↓</mo></math> transition, follow transitions until you’ve consumed <em>k</em> terminals (2 in this example) from the input. These are the terminals of the column in the parse table, and the rule of the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mo>↓</mo></math> transition gets put into that cell. You can also put the look-ahead into the automaton:</p>


<img src="https://blog.jeffsmits.net/graphviz/ll-single-automaton-lookahead.99854ad3ee7ebc2e.svg" alt="Single PDA using the automata from the grammar rules with lookahead noted"><h3 id="building-ll-tables-for-strong-ll-grammars-by-traditional-method">Building LL tables for strong LL grammars by traditional method</h3>
<p>While the above building of automata gives a visual intuition, it’s not the most efficient way to express how we can build LL tables. The traditional method does the same thing in essence, but using some pre-computed sets to calculate the cells in the table.</p>
<p>A cell at the row labeled with sort <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>A</mi></math> and the column labeled with terminal(s) <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>v</mi></math> should have the grammar rule <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>A</mi><mo>=</mo><mi>w</mi></math> (where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>w</mi></math> is a mix of terminals and sorts or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>ε</mi></math>), under the following condition: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>v</mi></math> is in the <em>First</em> set of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>w</mi></math>, or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>ε</mi></math> is in the <em>First</em> set of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>w</mi></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>v</mi></math> is in the <em>Follow</em> set of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>A</mi></math>. In other words: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>v</mi><mo>∈</mo><mrow><mi>F</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi></mrow><mo>(</mo><mi>w</mi><mo>)</mo><mo>·</mo><mrow><mi>F</mi><mi>o</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi>w</mi></mrow><mo>(</mo><mi>A</mi><mo>)</mo></math></p>
<p>Let’s unpack that. The <em>First</em> set of a terminal is a singleton set with that terminal. The <em>First</em> set of a sort is the set of first non-terminals that the sort can expand to, directly or indirectly. So a rule <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>A</mi><mo>=</mo><mi>a</mi><mo>[</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>]</mo></math> causes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>a</mi></math> to appear in the <em>First</em> set of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>A</mi></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>A</mi><mo>=</mo><mi>B</mi><mo>[</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>]</mo></math> causes the <em>First</em> set of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>B</mi></math> to be included in the <em>First</em> set of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>A</mi></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>A</mi><mo>=</mo><mi>ε</mi></math> causes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>ε</mi></math> to appear in the <em>First</em> set of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>A</mi></math>. This last rule says <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>A</mi></math> can be expanded to “nothing”, so if that’s an option we need to check the <em>Follow</em> set of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>A</mi></math>.</p>
<p>The <em>Follow</em> set is basically every non-terminal that can follow <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>A</mi></math> in the grammar. So when you have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>B</mi><mo>=</mo><mo>[</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>]</mo><mi>A</mi><mspace width="1em"/><mi>a</mi><mo>[</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>]</mo></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>a</mi></math> is in the <em>Follow</em> set of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>A</mi></math>. A rule <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>B</mi><mo>=</mo><mo>[</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>]</mo><mi>A</mi></math> causes the <em>Follow</em> set of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>B</mi></math> to be included in the <em>Follow</em> set of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>A</mi></math>. And the <em>Follow</em> set of the start symbol has the end-of-file ‘terminal’ <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi mathvariant="normal">$</mi></math>.</p>
<p>The <em>Follow</em> set is basically every non-terminal that can follow <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>A</mi></math> in the grammar. So when you have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>B</mi><mo>=</mo><mo>[</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>]</mo><mi>A</mi><mspace width="1em"/><mi>a</mi><mo>[</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>]</mo></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>a</mi></math> is in the <em>Follow</em> set of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>A</mi></math>. A rule <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>B</mi><mo>=</mo><mo>[</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>]</mo><mi>A</mi></math> causes the <em>Follow</em> set of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>B</mi></math> to be included in the <em>Follow</em> set of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>A</mi></math>. And the <em>Follow</em> set of the start symbol has the end-of-file ‘terminal’ <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi mathvariant="normal">$</mi></math>.</p>
<p>Finally, there is the dot operator between the <em>First</em> and <em>Follow</em> sets: this is a <em>truncated product</em>, that takes every combination of the two sets, sticks them together (in order), and truncates to length k. That’s a bit of an abstraction over the k in LL(k), which I didn’t take into account in the explanation of <em>First</em> and <em>Follow</em> sets. The <em>First</em> sets should have length k strings of course, and so you may need to take more <em>First/Follow</em> sets into account when computing these. Another thing I glossed over is that we actually use the <em>First</em> set of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>w</mi></math>, a mix of terminals and sorts on the right-hand side of our grammar rules. If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>w</mi></math> is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>a</mi><mspace width="1em"/><mi>A</mi><mspace width="1em"/><mi>B</mi><mspace width="1em"/><mi>b</mi></math>, then its <em>First</em> set is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mo>{</mo><mi>a</mi><mo>}</mo><mo>·</mo><mrow><mi>F</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi></mrow><mo>(</mo><mi>A</mi><mo>)</mo><mo>·</mo><mrow><mi>F</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi></mrow><mo>(</mo><mi>B</mi><mo>)</mo><mo>·</mo><mo>{</mo><mi>b</mi><mo>}</mo></math>.</p>
<p>Ok, with that all done, we can use those tables. But before we do, a quick word about expressive power, because LL is not particularly powerful…</p>
<h3 id="limitations-and-expressive-power">Limitations and Expressive power</h3>
<p>There are always languages that cannot be captured by an LL(k) grammar that can be captured by an LL(k+1) grammar. In other words, look-ahead size is important in the expressivity of an LL grammar, and LL(k) for any specific k does not capture <em>all</em> deterministic context-free languages<sup class="footnote-reference" id="fr-nondet-1"><a href="#fn-nondet">[3]</a></sup>.</p>
<p>We’ve already seen an example of an LL(2) grammar, but what would be a language that cannot be captured by any LL(k)? Take the language of a’s followed by b’s, where the number of a’s <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mo>≥</mo></math> the number of b’s. Or as a grammar:</p>
<table><thead><tr><th style="text-align: left"></th><th style="text-align: left"></th></tr></thead><tbody>
<tr><td style="text-align: left"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>S</mi><mo>=</mo><mi>a</mi><mi>S</mi></math></td><td style="text-align: left">(1)</td></tr>
<tr><td style="text-align: left"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>S</mi><mo>=</mo><mi>A</mi></math></td><td style="text-align: left">(2)</td></tr>
<tr><td style="text-align: left"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>A</mi><mo>=</mo><mi>a</mi><mi>A</mi><mi>b</mi></math></td><td style="text-align: left">(3)</td></tr>
<tr><td style="text-align: left"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>A</mi><mo>=</mo><mi>ε</mi></math></td><td style="text-align: left">(4)</td></tr>
</tbody></table>
<p>The problem for LL here is that we would have to look ahead in the input until we read the entire input before we could decide whether we can start consuming the input with Rule 1 or Rule 2 (and then Rule 3).</p>
<p>There is a class of grammars called LL-regular (LLR) grammars captures all LL(k) grammars for any k and slightly more. These LLR grammars are cool in that they are still parseable in linear time, as long as you have something called a “regular partition” of your grammar. Getting that is an undecidable problem though. And since there is an LR(1) grammar that is not in LLR, this stuff is the trifecta of confusing, impractical, and less powerful<sup class="footnote-reference" id="fr-LLR-1"><a href="#fn-LLR">[4]</a></sup> than a much more useful technique that we will cover later in this post: LR. But first, going from tables to parsers!</p>
<h2 id="predictive-parsing">Predictive Parsing</h2>
<p>Since we already know what the tables mean, we can write a simple parse table interpreter to finish our <em>predictive parser</em>. The parser is called predictive because based on the <em>k</em> look-ahead terminals, we decide the grammar rule to use to continue parsing, which typically predicts some of the structure of the input well beyond the part we peeked at for the look-ahead.</p>
<p>Ok, let’s write a quick parse table interpreter for our LL(2) example. We’ll start with some definitions.</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">use </span><span>std</span><span style="color:#f29668;">::</span><span>collections</span><span style="color:#f29668;">::</span><span>HashMap</span><span style="color:#bfbab0cc;">;
</span><span style="color:#ff7733;">use </span><span>std</span><span style="color:#f29668;">::</span><span>env</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span style="color:#ff7733;">use </span><span>lazy_static</span><span style="color:#f29668;">::</span><span>lazy_static</span><span style="color:#bfbab0cc;">;
</span><span style="color:#ff7733;">use </span><span>peekmore</span><span style="color:#f29668;">::</span><span>PeekMore</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span style="color:#ff7733;">type </span><span style="color:#59c2ff;">Terminal </span><span style="color:#f29668;">= </span><span style="color:#ff7733;">char</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span style="color:#bfbab0cc;">#</span><span>[</span><span style="color:#ffb454;">derive</span><span>(Clone</span><span style="color:#bfbab0cc;">,</span><span> Copy</span><span style="color:#bfbab0cc;">,</span><span> Debug</span><span style="color:#bfbab0cc;">,</span><span> Eq</span><span style="color:#bfbab0cc;">,</span><span> Hash</span><span style="color:#bfbab0cc;">,</span><span> PartialEq)]
</span><span style="color:#ff7733;">enum </span><span style="color:#59c2ff;">Sort </span><span>{
</span><span>    S</span><span style="color:#bfbab0cc;">,
</span><span>    </span><span style="color:#f29718;">A1</span><span style="color:#bfbab0cc;">,
</span><span>    </span><span style="color:#f29718;">A2</span><span style="color:#bfbab0cc;">,
</span><span>}
</span><span>
</span><span style="color:#ff7733;">enum </span><span style="color:#59c2ff;">Symbol </span><span>{
</span><span>    Sort(Sort)</span><span style="color:#bfbab0cc;">,
</span><span>    Terminal(Terminal)</span><span style="color:#bfbab0cc;">,
</span><span>}
</span><span>
</span><span style="color:#bfbab0cc;">#</span><span>[</span><span style="color:#ffb454;">derive</span><span>(Debug</span><span style="color:#bfbab0cc;">,</span><span> Eq</span><span style="color:#bfbab0cc;">,</span><span> PartialEq)]
</span><span style="color:#ff7733;">enum </span><span style="color:#59c2ff;">Rule </span><span>{
</span><span>    S</span><span style="color:#bfbab0cc;">,
</span><span>    Aa</span><span style="color:#bfbab0cc;">,
</span><span>    AEpsilon</span><span style="color:#bfbab0cc;">,
</span><span>}
</span></code></pre>
<p>The imports become useful in a second, for now we have our terminals, sorts, a combination type <code>Symbol</code>, and the names of our grammar rules. Assuming we keep around a proper PDA stack of symbols, we can write our grammar rules now:</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">impl </span><span style="color:#59c2ff;">Rule </span><span>{
</span><span>    </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">apply</span><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#f29718;">self</span><span>, </span><span style="color:#f29718;">stack</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;Symbol&gt;) {
</span><span>        </span><span style="color:#ff7733;">match </span><span style="font-style:italic;color:#39bae6;">self </span><span>{
</span><span>            Rule</span><span style="color:#f29668;">::</span><span>S </span><span style="color:#f29668;">=&gt; </span><span style="color:#ff7733;">Self</span><span style="color:#f29668;">::</span><span>s(stack)</span><span style="color:#bfbab0cc;">,
</span><span>            Rule</span><span style="color:#f29668;">::</span><span>Aa </span><span style="color:#f29668;">=&gt; </span><span style="color:#ff7733;">Self</span><span style="color:#f29668;">::</span><span>aa(stack)</span><span style="color:#bfbab0cc;">,
</span><span>            Rule</span><span style="color:#f29668;">::</span><span>AEpsilon </span><span style="color:#f29668;">=&gt; </span><span style="color:#ff7733;">Self</span><span style="color:#f29668;">::</span><span>a_epsilon(stack)</span><span style="color:#bfbab0cc;">,
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">s</span><span>(</span><span style="color:#f29718;">stack</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;Symbol&gt;) {
</span><span>        stack</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(Symbol</span><span style="color:#f29668;">::</span><span>Terminal(</span><span style="color:#c2d94c;">&#39;a&#39;</span><span>))</span><span style="color:#bfbab0cc;">;
</span><span>        stack</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(Symbol</span><span style="color:#f29668;">::</span><span>Terminal(</span><span style="color:#c2d94c;">&#39;b&#39;</span><span>))</span><span style="color:#bfbab0cc;">;
</span><span>        stack</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(Symbol</span><span style="color:#f29668;">::</span><span>Sort(Sort</span><span style="color:#f29668;">::</span><span style="color:#f29718;">A2</span><span>))</span><span style="color:#bfbab0cc;">;
</span><span>        stack</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(Symbol</span><span style="color:#f29668;">::</span><span>Terminal(</span><span style="color:#c2d94c;">&#39;b&#39;</span><span>))</span><span style="color:#bfbab0cc;">;
</span><span>        stack</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(Symbol</span><span style="color:#f29668;">::</span><span>Terminal(</span><span style="color:#c2d94c;">&#39;a&#39;</span><span>))</span><span style="color:#bfbab0cc;">;
</span><span>        stack</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(Symbol</span><span style="color:#f29668;">::</span><span>Sort(Sort</span><span style="color:#f29668;">::</span><span style="color:#f29718;">A1</span><span>))</span><span style="color:#bfbab0cc;">;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">aa</span><span>(</span><span style="color:#f29718;">stack</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;Symbol&gt;) {
</span><span>        stack</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(Symbol</span><span style="color:#f29668;">::</span><span>Terminal(</span><span style="color:#c2d94c;">&#39;a&#39;</span><span>))</span><span style="color:#bfbab0cc;">;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#bfbab0cc;">#</span><span>[</span><span style="color:#ffb454;">allow</span><span>(clippy::ptr_arg)]
</span><span>    </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">a_epsilon</span><span>(</span><span style="color:#f29718;">_stack</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;Symbol&gt;) {}
</span><span>}
</span></code></pre>
<p>Clippy is great for catching all kinds of poor code, but for consistency I’ve chosen to <code>#[allow]</code> this time. Note that to effectively run a context-free grammar on a PDA, you need to push the symbols in your rules on the stack in reverse, <a href="https://blog.jeffsmits.net/ll-parsing-recursive-descent/#context-free-grammars-derivations-and-a-naive-pda-translation">as mentioned in the recap</a>.</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#f07178;">lazy_static! </span><span>{
</span><span>    </span><span style="color:#ff7733;">static ref </span><span style="color:#f29718;">TABLE</span><span style="color:#bfbab0cc;">: </span><span>HashMap&lt;(Sort, Terminal, Terminal), Rule&gt; </span><span style="color:#f29668;">= </span><span>{
</span><span>        </span><span style="color:#ff7733;">let mut</span><span> table </span><span style="color:#f29668;">= </span><span>HashMap</span><span style="color:#f29668;">::</span><span>new()</span><span style="color:#bfbab0cc;">;
</span><span>        </span><span style="color:#f07178;">assert_eq!</span><span>(</span><span style="font-style:italic;color:#39bae6;">None</span><span style="color:#bfbab0cc;">,</span><span> table</span><span style="color:#f29668;">.</span><span style="color:#f07178;">insert</span><span>((Sort</span><span style="color:#f29668;">::</span><span>S</span><span style="color:#bfbab0cc;">,  </span><span style="color:#c2d94c;">&#39;a&#39;</span><span style="color:#bfbab0cc;">, </span><span style="color:#c2d94c;">&#39;a&#39;</span><span>)</span><span style="color:#bfbab0cc;">, </span><span>Rule</span><span style="color:#f29668;">::</span><span>S))</span><span style="color:#bfbab0cc;">;
</span><span>        </span><span style="color:#f07178;">assert_eq!</span><span>(</span><span style="font-style:italic;color:#39bae6;">None</span><span style="color:#bfbab0cc;">,</span><span> table</span><span style="color:#f29668;">.</span><span style="color:#f07178;">insert</span><span>((Sort</span><span style="color:#f29668;">::</span><span>S</span><span style="color:#bfbab0cc;">,  </span><span style="color:#c2d94c;">&#39;a&#39;</span><span style="color:#bfbab0cc;">, </span><span style="color:#c2d94c;">&#39;b&#39;</span><span>)</span><span style="color:#bfbab0cc;">, </span><span>Rule</span><span style="color:#f29668;">::</span><span>S))</span><span style="color:#bfbab0cc;">;
</span><span>        </span><span style="color:#f07178;">assert_eq!</span><span>(</span><span style="font-style:italic;color:#39bae6;">None</span><span style="color:#bfbab0cc;">,</span><span> table</span><span style="color:#f29668;">.</span><span style="color:#f07178;">insert</span><span>((Sort</span><span style="color:#f29668;">::</span><span style="color:#f29718;">A1</span><span style="color:#bfbab0cc;">, </span><span style="color:#c2d94c;">&#39;a&#39;</span><span style="color:#bfbab0cc;">, </span><span style="color:#c2d94c;">&#39;a&#39;</span><span>)</span><span style="color:#bfbab0cc;">, </span><span>Rule</span><span style="color:#f29668;">::</span><span>Aa))</span><span style="color:#bfbab0cc;">;
</span><span>        </span><span style="color:#f07178;">assert_eq!</span><span>(</span><span style="font-style:italic;color:#39bae6;">None</span><span style="color:#bfbab0cc;">,</span><span> table</span><span style="color:#f29668;">.</span><span style="color:#f07178;">insert</span><span>((Sort</span><span style="color:#f29668;">::</span><span style="color:#f29718;">A1</span><span style="color:#bfbab0cc;">, </span><span style="color:#c2d94c;">&#39;a&#39;</span><span style="color:#bfbab0cc;">, </span><span style="color:#c2d94c;">&#39;b&#39;</span><span>)</span><span style="color:#bfbab0cc;">, </span><span>Rule</span><span style="color:#f29668;">::</span><span>AEpsilon))</span><span style="color:#bfbab0cc;">;
</span><span>        </span><span style="color:#f07178;">assert_eq!</span><span>(</span><span style="font-style:italic;color:#39bae6;">None</span><span style="color:#bfbab0cc;">,</span><span> table</span><span style="color:#f29668;">.</span><span style="color:#f07178;">insert</span><span>((Sort</span><span style="color:#f29668;">::</span><span style="color:#f29718;">A2</span><span style="color:#bfbab0cc;">, </span><span style="color:#c2d94c;">&#39;a&#39;</span><span style="color:#bfbab0cc;">, </span><span style="color:#c2d94c;">&#39;b&#39;</span><span>)</span><span style="color:#bfbab0cc;">, </span><span>Rule</span><span style="color:#f29668;">::</span><span>Aa))</span><span style="color:#bfbab0cc;">;
</span><span>        </span><span style="color:#f07178;">assert_eq!</span><span>(</span><span style="font-style:italic;color:#39bae6;">None</span><span style="color:#bfbab0cc;">,</span><span> table</span><span style="color:#f29668;">.</span><span style="color:#f07178;">insert</span><span>((Sort</span><span style="color:#f29668;">::</span><span style="color:#f29718;">A2</span><span style="color:#bfbab0cc;">, </span><span style="color:#c2d94c;">&#39;b&#39;</span><span style="color:#bfbab0cc;">, </span><span style="color:#c2d94c;">&#39;a&#39;</span><span>)</span><span style="color:#bfbab0cc;">, </span><span>Rule</span><span style="color:#f29668;">::</span><span>AEpsilon))</span><span style="color:#bfbab0cc;">;
</span><span>        table
</span><span>    }</span><span style="color:#bfbab0cc;">;
</span><span>}
</span></code></pre>
<p>Nothing very special really, just encoding what we had already. The main parse loop is also very unexciting now that we have implemented most of the logic of the grammar already. We basically manage the stack, eliminating terminals on the stack with those from the input and applying rules from the table based on sort and look-ahead, and give errors if we get unexpected input:</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">pub fn </span><span style="color:#ffb454;">lex</span><span>(</span><span style="color:#f29718;">input</span><span style="color:#bfbab0cc;">:</span><span> String) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;Terminal&gt; {
</span><span>    input</span><span style="color:#f29668;">.</span><span style="color:#f07178;">chars</span><span>()</span><span style="color:#f29668;">.</span><span style="color:#f07178;">collect</span><span>()
</span><span>}
</span><span>
</span><span style="color:#ff7733;">pub fn </span><span style="color:#ffb454;">main</span><span>() </span><span style="color:#bfbab0cc;">-&gt; </span><span style="font-style:italic;color:#39bae6;">Result</span><span>&lt;(), </span><span style="font-style:italic;color:#39bae6;">String</span><span>&gt; {
</span><span>    </span><span style="color:#ff7733;">let</span><span> input </span><span style="color:#f29668;">= </span><span>env</span><span style="color:#f29668;">::</span><span>args()</span><span style="color:#f29668;">.</span><span style="color:#f07178;">next</span><span>()</span><span style="color:#f29668;">.</span><span style="color:#f07178;">expect</span><span>(</span><span style="color:#c2d94c;">&quot;Argument string to parse&quot;</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#ff7733;">let</span><span> input </span><span style="color:#f29668;">= </span><span style="color:#f07178;">lex</span><span>(input)</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#ff7733;">let mut</span><span> input </span><span style="color:#f29668;">=</span><span> input</span><span style="color:#f29668;">.</span><span style="color:#f07178;">iter</span><span>()</span><span style="color:#f29668;">.</span><span style="color:#f07178;">peekmore</span><span>()</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#ff7733;">let mut</span><span> stack </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">Vec</span><span style="color:#f29668;">::</span><span>new()</span><span style="color:#bfbab0cc;">;
</span><span>    stack</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(Symbol</span><span style="color:#f29668;">::</span><span>Sort(Sort</span><span style="color:#f29668;">::</span><span>S))</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#ff7733;">while let </span><span style="font-style:italic;color:#39bae6;">Some</span><span>(symbol) </span><span style="color:#f29668;">=</span><span> stack</span><span style="color:#f29668;">.</span><span style="color:#f07178;">pop</span><span>() {
</span><span>        </span><span style="color:#ff7733;">return match</span><span> symbol {
</span><span>            Symbol</span><span style="color:#f29668;">::</span><span>Terminal(predicted) </span><span style="color:#f29668;">=&gt; </span><span>{
</span><span>                </span><span style="color:#ff7733;">if let </span><span style="font-style:italic;color:#39bae6;">Some</span><span>(</span><span style="color:#f29668;">&amp;&amp;</span><span>actual) </span><span style="color:#f29668;">=</span><span> input</span><span style="color:#f29668;">.</span><span style="color:#f07178;">next</span><span>() {
</span><span>                    </span><span style="color:#ff7733;">if</span><span> predicted </span><span style="color:#f29668;">==</span><span> actual {
</span><span>                        </span><span style="color:#ff7733;">continue</span><span style="color:#bfbab0cc;">;
</span><span>                    }
</span><span>                    </span><span style="font-style:italic;color:#39bae6;">Err</span><span>(</span><span style="color:#f07178;">format!</span><span>(
</span><span>                        </span><span style="color:#c2d94c;">&quot;Expected terminal </span><span style="color:#f29718;">{predicted:?}</span><span style="color:#c2d94c;">, but got </span><span style="color:#f29718;">{actual:?}</span><span style="color:#c2d94c;">.&quot;
</span><span>                    ))
</span><span>                } </span><span style="color:#ff7733;">else </span><span>{
</span><span>                    </span><span style="font-style:italic;color:#39bae6;">Err</span><span>(</span><span style="color:#f07178;">format!</span><span>(</span><span style="color:#c2d94c;">&quot;Expected terminal </span><span style="color:#f29718;">{predicted:?}</span><span style="color:#c2d94c;">, but got EOF.&quot;</span><span>))
</span><span>                }
</span><span>            }
</span><span>            Symbol</span><span style="color:#f29668;">::</span><span>Sort(sort) </span><span style="color:#f29668;">=&gt; </span><span>{
</span><span>                </span><span style="color:#ff7733;">if let </span><span style="color:#f29668;">&amp;</span><span>[</span><span style="font-style:italic;color:#39bae6;">Some</span><span>(</span><span style="color:#f29668;">&amp;</span><span>term1)</span><span style="color:#bfbab0cc;">, </span><span style="font-style:italic;color:#39bae6;">Some</span><span>(</span><span style="color:#f29668;">&amp;</span><span>term2)] </span><span style="color:#f29668;">=</span><span> input</span><span style="color:#f29668;">.</span><span style="color:#f07178;">peek_amount</span><span>(</span><span style="color:#f29718;">2</span><span>) {
</span><span>                    </span><span style="color:#ff7733;">if let </span><span style="font-style:italic;color:#39bae6;">Some</span><span>(r) </span><span style="color:#f29668;">= </span><span style="color:#f29718;">TABLE</span><span style="color:#f29668;">.</span><span style="color:#f07178;">get</span><span>(</span><span style="color:#f29668;">&amp;</span><span>(sort</span><span style="color:#bfbab0cc;">,</span><span> term1</span><span style="color:#bfbab0cc;">,</span><span> term2)) {
</span><span>                        r</span><span style="color:#f29668;">.</span><span style="color:#f07178;">apply</span><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut</span><span> stack)</span><span style="color:#bfbab0cc;">;
</span><span>                        </span><span style="color:#ff7733;">continue</span><span style="color:#bfbab0cc;">;
</span><span>                    } </span><span style="color:#ff7733;">else </span><span>{
</span><span>                        </span><span style="font-style:italic;color:#39bae6;">Err</span><span>(</span><span style="color:#f07178;">format!</span><span>(
</span><span>                            </span><span style="color:#c2d94c;">&quot;Unexpected </span><span style="color:#f29718;">{term1:?} {term2:?}</span><span style="color:#c2d94c;"> while parsing </span><span style="color:#f29718;">{sort:?}</span><span style="color:#c2d94c;">&quot;
</span><span>                        ))
</span><span>                    }
</span><span>                } </span><span style="color:#ff7733;">else </span><span>{
</span><span>                    </span><span style="font-style:italic;color:#39bae6;">Err</span><span>(</span><span style="color:#c2d94c;">&quot;Unexpected end of input.&quot;</span><span style="color:#f29668;">.</span><span style="color:#f07178;">to_owned</span><span>())
</span><span>                }
</span><span>            }
</span><span>        }</span><span style="color:#bfbab0cc;">;
</span><span>    }
</span><span>    </span><span style="font-style:italic;color:#39bae6;">Ok</span><span>(())
</span><span>}
</span></code></pre>
<h2 id="recursive-descent">Recursive Descent</h2>
<p>By encoding the parse table in data, we get some amount of <em>interpretive overhead</em>. We have a parse table interpreter with a stack we manage ourselves, but the stack is not really used any different from a call stack. So what if we use function calls instead? That’s the idea of <em>recursive descent</em> parsing. It actually makes our code smaller and more straight-forward, which is why it’s so popular as a technique for hand-written parsers.</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">use </span><span>std</span><span style="color:#f29668;">::</span><span>env</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span style="color:#ff7733;">use </span><span>peekmore</span><span style="color:#f29668;">::</span><span>PeekMore</span><span style="color:#bfbab0cc;">;
</span><span style="color:#ff7733;">use </span><span>peekmore</span><span style="color:#f29668;">::</span><span>PeekMoreIterator</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span style="color:#ff7733;">type </span><span style="color:#59c2ff;">Iter</span><span style="color:#f29668;">&lt;</span><span style="color:#ff7733;">&#39;a</span><span style="color:#f29668;">&gt; = </span><span>PeekMoreIterator&lt;std</span><span style="color:#f29668;">::</span><span>slice</span><span style="color:#f29668;">::</span><span>Iter&lt;</span><span style="color:#ff7733;">&#39;a</span><span>, Terminal&gt;&gt;</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span style="color:#ff7733;">type </span><span style="color:#59c2ff;">Terminal </span><span style="color:#f29668;">= </span><span style="color:#ff7733;">char</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">consume</span><span>(</span><span style="color:#f29718;">input</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut</span><span> Iter, </span><span style="color:#f29718;">predicted</span><span style="color:#bfbab0cc;">:</span><span> Terminal) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="font-style:italic;color:#39bae6;">Result</span><span>&lt;(), </span><span style="font-style:italic;color:#39bae6;">String</span><span>&gt; {
</span><span>    </span><span style="color:#ff7733;">if let </span><span style="font-style:italic;color:#39bae6;">Some</span><span>(</span><span style="color:#f29668;">&amp;</span><span>actual) </span><span style="color:#f29668;">=</span><span> input</span><span style="color:#f29668;">.</span><span style="color:#f07178;">next</span><span>() {
</span><span>        </span><span style="color:#ff7733;">if</span><span> actual </span><span style="color:#f29668;">==</span><span> predicted {
</span><span>            </span><span style="font-style:italic;color:#39bae6;">Ok</span><span>(())
</span><span>        } </span><span style="color:#ff7733;">else </span><span>{
</span><span>            </span><span style="font-style:italic;color:#39bae6;">Err</span><span>(</span><span style="color:#f07178;">format!</span><span>(
</span><span>                </span><span style="color:#c2d94c;">&quot;Expected terminal </span><span style="color:#f29718;">{predicted:?}</span><span style="color:#c2d94c;">, but got </span><span style="color:#f29718;">{actual:?}</span><span style="color:#c2d94c;">.&quot;
</span><span>            ))
</span><span>        }
</span><span>    } </span><span style="color:#ff7733;">else </span><span>{
</span><span>        </span><span style="font-style:italic;color:#39bae6;">Err</span><span>(</span><span style="color:#c2d94c;">&quot;Unexpected end of file.&quot;</span><span style="color:#f29668;">.</span><span style="color:#f07178;">to_owned</span><span>())
</span><span>    }
</span><span>}
</span></code></pre>
<p>This time we only need terminals as a type, the rest is gone, and so is the hashmap import for the parsetable. We will need the input, and be able to remove predicted terminals from it, so <code>consume</code> comes in handy.</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">sort_s</span><span>(</span><span style="color:#f29718;">input</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut</span><span> Iter) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="font-style:italic;color:#39bae6;">Result</span><span>&lt;(), </span><span style="font-style:italic;color:#39bae6;">String</span><span>&gt; {
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// S
</span><span>    </span><span style="color:#ff7733;">match</span><span> input</span><span style="color:#f29668;">.</span><span style="color:#f07178;">peek_amount</span><span>(</span><span style="color:#f29718;">2</span><span>) {
</span><span>        </span><span style="color:#f29668;">&amp;</span><span>[</span><span style="font-style:italic;color:#39bae6;">Some</span><span>(</span><span style="color:#c2d94c;">&#39;a&#39;</span><span>)</span><span style="color:#bfbab0cc;">, </span><span style="font-style:italic;color:#39bae6;">Some</span><span>(</span><span style="color:#c2d94c;">&#39;a&#39;</span><span>)] </span><span style="color:#f29668;">=&gt; </span><span style="color:#f07178;">s</span><span>(input)</span><span style="color:#bfbab0cc;">,
</span><span>        </span><span style="color:#f29668;">&amp;</span><span>[</span><span style="font-style:italic;color:#39bae6;">Some</span><span>(</span><span style="color:#c2d94c;">&#39;a&#39;</span><span>)</span><span style="color:#bfbab0cc;">, </span><span style="font-style:italic;color:#39bae6;">Some</span><span>(</span><span style="color:#c2d94c;">&#39;b&#39;</span><span>)] </span><span style="color:#f29668;">=&gt; </span><span style="color:#f07178;">s</span><span>(input)</span><span style="color:#bfbab0cc;">,
</span><span>        </span><span style="color:#f29668;">&amp;</span><span>[term1</span><span style="color:#bfbab0cc;">,</span><span> term2] </span><span style="color:#f29668;">=&gt; </span><span style="font-style:italic;color:#39bae6;">Err</span><span>(</span><span style="color:#f07178;">format!</span><span>(</span><span style="color:#c2d94c;">&quot;Unexpected </span><span style="color:#f29718;">{term1:?} {term2:?}</span><span style="color:#c2d94c;"> while parsing S&quot;</span><span>))</span><span style="color:#bfbab0cc;">,
</span><span>        </span><span style="color:#f29668;">_ =&gt; </span><span style="font-style:italic;color:#39bae6;">Err</span><span>(</span><span style="color:#c2d94c;">&quot;Unexpected end of file.&quot;</span><span style="color:#f29668;">.</span><span style="color:#f07178;">to_owned</span><span>())</span><span style="color:#bfbab0cc;">,
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">sort_A1</span><span>(</span><span style="color:#f29718;">input</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut</span><span> Iter) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="font-style:italic;color:#39bae6;">Result</span><span>&lt;(), </span><span style="font-style:italic;color:#39bae6;">String</span><span>&gt; {
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// A1
</span><span>    </span><span style="color:#ff7733;">match</span><span> input</span><span style="color:#f29668;">.</span><span style="color:#f07178;">peek_amount</span><span>(</span><span style="color:#f29718;">2</span><span>) {
</span><span>        </span><span style="color:#f29668;">&amp;</span><span>[</span><span style="font-style:italic;color:#39bae6;">Some</span><span>(</span><span style="color:#c2d94c;">&#39;a&#39;</span><span>)</span><span style="color:#bfbab0cc;">, </span><span style="font-style:italic;color:#39bae6;">Some</span><span>(</span><span style="color:#c2d94c;">&#39;a&#39;</span><span>)] </span><span style="color:#f29668;">=&gt; </span><span style="color:#f07178;">a_a</span><span>(input)</span><span style="color:#bfbab0cc;">,
</span><span>        </span><span style="color:#f29668;">&amp;</span><span>[</span><span style="font-style:italic;color:#39bae6;">Some</span><span>(</span><span style="color:#c2d94c;">&#39;a&#39;</span><span>)</span><span style="color:#bfbab0cc;">, </span><span style="font-style:italic;color:#39bae6;">Some</span><span>(</span><span style="color:#c2d94c;">&#39;b&#39;</span><span>)] </span><span style="color:#f29668;">=&gt; </span><span style="color:#f07178;">a_epsilon</span><span>(input)</span><span style="color:#bfbab0cc;">,
</span><span>        </span><span style="color:#f29668;">&amp;</span><span>[term1</span><span style="color:#bfbab0cc;">,</span><span> term2] </span><span style="color:#f29668;">=&gt; </span><span style="font-style:italic;color:#39bae6;">Err</span><span>(</span><span style="color:#f07178;">format!</span><span>(</span><span style="color:#c2d94c;">&quot;Unexpected </span><span style="color:#f29718;">{term1:?} {term2:?}</span><span style="color:#c2d94c;"> while parsing A&quot;</span><span>))</span><span style="color:#bfbab0cc;">,
</span><span>        </span><span style="color:#f29668;">_ =&gt; </span><span style="font-style:italic;color:#39bae6;">Err</span><span>(</span><span style="color:#c2d94c;">&quot;Unexpected end of file.&quot;</span><span style="color:#f29668;">.</span><span style="color:#f07178;">to_owned</span><span>())</span><span style="color:#bfbab0cc;">,
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">sort_A2</span><span>(</span><span style="color:#f29718;">input</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut</span><span> Iter) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="font-style:italic;color:#39bae6;">Result</span><span>&lt;(), </span><span style="font-style:italic;color:#39bae6;">String</span><span>&gt; {
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// A2
</span><span>    </span><span style="color:#ff7733;">match</span><span> input</span><span style="color:#f29668;">.</span><span style="color:#f07178;">peek_amount</span><span>(</span><span style="color:#f29718;">2</span><span>) {
</span><span>        </span><span style="color:#f29668;">&amp;</span><span>[</span><span style="font-style:italic;color:#39bae6;">Some</span><span>(</span><span style="color:#c2d94c;">&#39;a&#39;</span><span>)</span><span style="color:#bfbab0cc;">, </span><span style="font-style:italic;color:#39bae6;">Some</span><span>(</span><span style="color:#c2d94c;">&#39;b&#39;</span><span>)] </span><span style="color:#f29668;">=&gt; </span><span style="color:#f07178;">a_a</span><span>(input)</span><span style="color:#bfbab0cc;">,
</span><span>        </span><span style="color:#f29668;">&amp;</span><span>[</span><span style="font-style:italic;color:#39bae6;">Some</span><span>(</span><span style="color:#c2d94c;">&#39;b&#39;</span><span>)</span><span style="color:#bfbab0cc;">, </span><span style="font-style:italic;color:#39bae6;">Some</span><span>(</span><span style="color:#c2d94c;">&#39;a&#39;</span><span>)] </span><span style="color:#f29668;">=&gt; </span><span style="color:#f07178;">a_epsilon</span><span>(input)</span><span style="color:#bfbab0cc;">,
</span><span>        </span><span style="color:#f29668;">&amp;</span><span>[term1</span><span style="color:#bfbab0cc;">,</span><span> term2] </span><span style="color:#f29668;">=&gt; </span><span style="font-style:italic;color:#39bae6;">Err</span><span>(</span><span style="color:#f07178;">format!</span><span>(</span><span style="color:#c2d94c;">&quot;Unexpected </span><span style="color:#f29718;">{term1:?} {term2:?}</span><span style="color:#c2d94c;"> while parsing A&quot;</span><span>))</span><span style="color:#bfbab0cc;">,
</span><span>        </span><span style="color:#f29668;">_ =&gt; </span><span style="font-style:italic;color:#39bae6;">Err</span><span>(</span><span style="color:#c2d94c;">&quot;Unexpected end of file.&quot;</span><span style="color:#f29668;">.</span><span style="color:#f07178;">to_owned</span><span>())</span><span style="color:#bfbab0cc;">,
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">s</span><span>(</span><span style="color:#f29718;">input</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut</span><span> Iter) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="font-style:italic;color:#39bae6;">Result</span><span>&lt;(), </span><span style="font-style:italic;color:#39bae6;">String</span><span>&gt; {
</span><span>    sort_A1(input)</span><span style="color:#f29668;">?</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#f07178;">consume</span><span>(input</span><span style="color:#bfbab0cc;">, </span><span style="color:#c2d94c;">&#39;a&#39;</span><span>)</span><span style="color:#f29668;">?</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#f07178;">consume</span><span>(input</span><span style="color:#bfbab0cc;">, </span><span style="color:#c2d94c;">&#39;b&#39;</span><span>)</span><span style="color:#f29668;">?</span><span style="color:#bfbab0cc;">;
</span><span>    sort_A2(input)</span><span style="color:#f29668;">?</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#f07178;">consume</span><span>(input</span><span style="color:#bfbab0cc;">, </span><span style="color:#c2d94c;">&#39;b&#39;</span><span>)</span><span style="color:#f29668;">?</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#f07178;">consume</span><span>(input</span><span style="color:#bfbab0cc;">, </span><span style="color:#c2d94c;">&#39;a&#39;</span><span>)
</span><span>}
</span><span>
</span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">a_a</span><span>(</span><span style="color:#f29718;">input</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut</span><span> Iter) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="font-style:italic;color:#39bae6;">Result</span><span>&lt;(), </span><span style="font-style:italic;color:#39bae6;">String</span><span>&gt; {
</span><span>    </span><span style="color:#f07178;">consume</span><span>(input</span><span style="color:#bfbab0cc;">, </span><span style="color:#c2d94c;">&#39;a&#39;</span><span>)
</span><span>}
</span><span>
</span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">a_epsilon</span><span>(</span><span style="color:#f29718;">_input</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut</span><span> Iter) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="font-style:italic;color:#39bae6;">Result</span><span>&lt;(), </span><span style="font-style:italic;color:#39bae6;">String</span><span>&gt; {
</span><span>    </span><span style="font-style:italic;color:#39bae6;">Ok</span><span>(())
</span><span>}
</span></code></pre>
<p>Our parse table has now become code directly, with these functions named after the sorts of the rows. They call rules that are also functions, which in turn use the sort functions. Those rules also use <code>consume</code>, this time without having to reverse the order of the rule body.</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">pub fn </span><span style="color:#ffb454;">lex</span><span>(</span><span style="color:#f29718;">input</span><span style="color:#bfbab0cc;">:</span><span> String) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;Terminal&gt; {
</span><span>    input</span><span style="color:#f29668;">.</span><span style="color:#f07178;">chars</span><span>()</span><span style="color:#f29668;">.</span><span style="color:#f07178;">collect</span><span>()
</span><span>}
</span><span>
</span><span style="color:#ff7733;">pub fn </span><span style="color:#ffb454;">main</span><span>() </span><span style="color:#bfbab0cc;">-&gt; </span><span style="font-style:italic;color:#39bae6;">Result</span><span>&lt;(), </span><span style="font-style:italic;color:#39bae6;">String</span><span>&gt; {
</span><span>    </span><span style="color:#ff7733;">let</span><span> input </span><span style="color:#f29668;">= </span><span>env</span><span style="color:#f29668;">::</span><span>args()</span><span style="color:#f29668;">.</span><span style="color:#f07178;">next</span><span>()</span><span style="color:#f29668;">.</span><span style="color:#f07178;">expect</span><span>(</span><span style="color:#c2d94c;">&quot;Argument string to parse&quot;</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#ff7733;">let</span><span> input </span><span style="color:#f29668;">= </span><span style="color:#f07178;">lex</span><span>(input)</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#ff7733;">let mut</span><span> input </span><span style="color:#f29668;">=</span><span> input</span><span style="color:#f29668;">.</span><span style="color:#f07178;">iter</span><span>()</span><span style="color:#f29668;">.</span><span style="color:#f07178;">peekmore</span><span>()</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#f07178;">sort_s</span><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut</span><span> input)
</span><span>}
</span></code></pre>
<p>Finally, our main function just calls the right sort function instead of putting that sort on the stack. And the loop is gone, since we now use recursion.</p>
<h2 id="summary-of-ll-and-an-insight-from-the-automaton">Summary of LL, and an insight from the automaton</h2>
<p>We’ve now seen LL(k) parsing, left-to-right leftmost derivation. This leftmost derivation directly corresponds to walking through the parse tree topdown, depth-first, leftmost child first. Whenever we expand a leftmost sort by a rule for that sort, we have to choose a rule, therefore we use the look-ahead (with a length of <em>k</em>) to see ahead and choose based on this.</p>
<p>We’ve seen an LL(1) and an LL(2) grammar, and in general more look-ahead allows us to parse more grammars <em>and</em> more languages. Both are important: certain languages cannot be expressed in LL(1) or LL(2), and some LL(1) grammars are harder to read and write than the LL(2) grammar of the same language.</p>
<p>We’ve seen how we can construct simple DFAs for each rule in our grammar, and then replace the sort transitions <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><msub><mi>N</mi><mn>1</mn></msub><msup><mo>→</mo><mi>A</mi></msup><msub><mi>N</mi><mn>2</mn></msub></math> by a (PDA) push transition (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mo>↓</mo><mi>A</mi></math>) from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><msub><mi>N</mi><mn>1</mn></msub></math> to all starts of DFAs corresponding to rules of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>A</mi></math>, and a pop transition (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mo>↑</mo><mi>A</mi></math>) from the ends of those DFAs to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><msub><mi>N</mi><mn>2</mn></msub></math>. Then the LL table, the decision table of sort + look-ahead = rule, naturally follows from this PDA by finding what input will be consumed if a certain rule is chosen, and using that as the look-ahead to make the decision for that rule.</p>
<p>The recursive descent way of writing a parser directly as code is nice and simple, it really just follows the grammar. Since you’re writing plain old code with function calls, you can imagine people have found nice ways to extend and adapt the pattern of recursive descent parsers. For one, it’s quite easy to reason about where you are in the parse when hitting an error state, which makes it fairly easy to give friendly error messages when the parser doesn’t accept an input. You can also use a trick to fix up direct left-recursion called <a href="https://en.wikipedia.org/wiki/Tail_recursive_parser">node reparenting</a>, where you use a loop or tail-recursion locally construct the tree bottom-up. You could argue that such a parser is a hybrid between recursive descent and ascent, a “recursive descent-ascent parser”.</p>
<p>Finally, if we look back at the automaton, we can see that the PDAs we build have a very strict shape. We either have a non-deterministic choice due to multiple push transitions for a sort, or we have predicted input, a single path of terminals to consume from the input. If we think back to the <a href="https://blog.jeffsmits.net/finite-automata/">NFAs and DFAs</a> from early on in this blog post series, those used the input to chose what state to go to next. Now we have single-path DFAs that just consume input, and a separate table on a look-ahead to resolve non-determinism from the pushes and pops. The strict shape here indicated that we’re not really making full use of the power of automata. This will change with the next parsing technique.</p>
<h1 id="continue">Continue?</h1>
<p>Now that you’ve learned all about LL parsing, would you like to learn about LR parsing? About how it’s more powerful, also uses parse tables with some of the same construction tricks, also has nice corresponding push-down automata, and even has an analogue to recursive descent? Then click on to <a href="https://blog.jeffsmits.net/lr-parsing-recursive-ascent/">part 2</a>! Or bookmark it for later, when you are able to absorb information again or whatever ¯\_(ツ)_/¯</p>
<hr><ol class="footnotes-list">
<li id="fn-LLdef">
<p>I’m fairly sure my prose description there is the same as a formal definition, and it feel a bit nicer to think about than <a href="https://en.wikipedia.org/wiki/LL_grammar#Formal_definition">the ones you can find on Wikipedia</a>. <a href="#fr-LLdef-1">↩</a></p>
</li>
<li id="fn-table">
<p>Technically you’d need to see <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><msub><mi>A</mi><mn>1</mn></msub></math>  and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><msub><mi>A</mi><mn>2</mn></msub></math>  as separate symbols and duplicate the rules for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>A</mi></math> , resulting in a larger grammar in correspondence with the larger table. But I couldn’t be bothered, and the parse table as shown works just as well. This is relevant to the code size of a recursive descent parser too, since you can just reuse the code for rules 2 and 3 instead of having duplicate code for the two extra rules. What’s a recursive descent parser? That comes just a little later in the post, so keep reading ;) <a href="#fr-table-1">↩</a></p>
</li>
<li id="fn-nondet">
<p>Yes, there are non-deterministic context-free languages. Those are the context-free languages that can only be parsed with a non-deterministic PDA. Since this post is about deterministic parsers, we’ll ignore the non-deterministic languages. <a href="#fr-nondet-1">↩</a></p>
</li>
<li id="fn-LLR">
<p>While I find the <a href="https://en.wikipedia.org/wiki/LL_grammar#Regular_case">Wikipedia article on LLR</a> confusing, and it makes a good case for why it’s not really used, I’m still somewhat intrigued. This is one of those things that will stay on my reading list for a while I think, something I still want to understand further… <a href="#fr-LLR-1">↩</a></p>
</li>
</ol>

  </main>
  <p>
        Tags:
          <a href="https://blog.jeffsmits.net/tags/theory-of-computation/">#theory of computation</a>
          <a href="https://blog.jeffsmits.net/tags/automata/">#automata</a>
          <a href="https://blog.jeffsmits.net/tags/context-free-grammar/">#context-free grammar</a>
          <a href="https://blog.jeffsmits.net/tags/pda/">#pda</a>
          <a href="https://blog.jeffsmits.net/tags/parsing/">#parsing</a>
  </p>
<footer>
    Made with <a href="https://codeberg.org/alanpearce/zola-bearblog">Zola ʕ•ᴥ•ʔ Bear</a>
</footer>
</body>
</html>
